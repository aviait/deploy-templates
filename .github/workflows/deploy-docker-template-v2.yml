name: Deploy Docker Project (vars/secrets only)

on:
  workflow_call: {}

jobs:
  deploy:
    name: "ðŸš€ Deploy ${{
      vars.PROJECT_NAME
    }} (${{ vars.ENVIRONMENT }})"
    runs-on: ubuntu-latest
    timeout-minutes: 30

    concurrency:
      group: deploy-docker-${{ vars.PROJECT_NAME }}-${{ vars.ENVIRONMENT }}
      cancel-in-progress: true

    permissions:
      contents: read

    # Se vocÃª NÃƒO usa Environment do GitHub, pode remover essa linha.
    # Se usa, essa linha depende de vars.ENVIRONMENT (var do repo).
    environment: ${{ vars.ENVIRONMENT }}

    defaults:
      run:
        shell: bash

    outputs:
      version: ${{ steps.version.outputs.version }}
      image_ref: ${{ steps.image_metadata.outputs.image_ref }}

    env:
      # BÃ¡sico (VARS)
      PROJECT_NAME: ${{ vars.PROJECT_NAME }}
      ENVIRONMENT: ${{ vars.ENVIRONMENT }}

      # Credenciais/registry (VARS)
      DOCKER_USERNAME: ${{ vars.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ vars.DOCKER_PASSWORD }}
      REGISTRY: ${{ vars.REGISTRY != '' && vars.REGISTRY || 'docker.io' }}
      IMAGE_NAMESPACE: ${{ vars.IMAGE_NAMESPACE != '' && vars.IMAGE_NAMESPACE || vars.DOCKER_USERNAME }}

      # Deploy target (VARS)
      SSH_USER: ${{ vars.SSH_USER }}
      SSH_HOST: ${{ vars.SSH_HOST }}
      SSH_REMOTE_PORT: ${{ vars.SSH_REMOTE_PORT != '' && vars.SSH_REMOTE_PORT || '22' }}
      SSH_KNOWN_HOSTS: ${{ vars.SSH_KNOWN_HOSTS }}

      # App/container (VARS)
      DOCKER_IMAGE: ${{ vars.DOCKER_IMAGE }}
      CONTAINER_NAME: ${{ vars.CONTAINER_NAME }}

      # Portas (VARS)
      HOST_PORT: ${{ vars.HOST_PORT }}
      PORT: ${{ vars.PORT }}

      # Build (VARS com defaults)
      NODE_VERSION: ${{ vars.NODE_VERSION != '' && vars.NODE_VERSION || '22' }}
      PACKAGE_MANAGER: ${{ vars.PACKAGE_MANAGER != '' && vars.PACKAGE_MANAGER || 'yarn' }}
      INSTALL_CMD: ${{ vars.INSTALL_CMD != '' && vars.INSTALL_CMD || 'yarn install --immutable' }}
      BUILD_CMD: ${{ vars.BUILD_CMD != '' && vars.BUILD_CMD || 'yarn build' }}
      VERSION_CMD: ${{ vars.VERSION_CMD != '' && vars.VERSION_CMD || 'node -p "require(\"./package.json\").version"' }}
      CACHE_DEPENDENCY_PATH: ${{ vars.CACHE_DEPENDENCY_PATH }}

      # Docker build (VARS com defaults)
      DOCKER_PLATFORM: ${{ vars.DOCKER_PLATFORM != '' && vars.DOCKER_PLATFORM || 'linux/amd64' }}
      DOCKER_BUILD_ARGS: ${{ vars.DOCKER_BUILD_ARGS }}

      # Healthcheck/retention (VARS com defaults)
      IMAGE_RETENTION_COUNT: ${{ vars.IMAGE_RETENTION_COUNT != '' && vars.IMAGE_RETENTION_COUNT || '5' }}
      REMOTE_DOCKER_LOGIN: ${{ vars.REMOTE_DOCKER_LOGIN != '' && vars.REMOTE_DOCKER_LOGIN || 'true' }}
      HEALTHCHECK_URL: ${{ vars.HEALTHCHECK_URL }}
      HEALTHCHECK_RETRIES: ${{ vars.HEALTHCHECK_RETRIES != '' && vars.HEALTHCHECK_RETRIES || '12' }}
      HEALTHCHECK_DELAY: ${{ vars.HEALTHCHECK_DELAY != '' && vars.HEALTHCHECK_DELAY || '5' }}

      # Runner cleanup (VARS com default)
      PRUNE_RUNNER: ${{ vars.PRUNE_RUNNER != '' && vars.PRUNE_RUNNER || 'true' }}

    steps:
      - name: "âœ… ValidaÃ§Ã£o prÃ©via (obrigatÃ³rios)"
        run: |
          set -euo pipefail

          req_vars=(PROJECT_NAME ENVIRONMENT DOCKER_IMAGE SSH_USER SSH_HOST DOCKER_USERNAME DOCKER_PASSWORD HOST_PORT)

          for k in "${req_vars[@]}"; do
            v="${!k:-}"
            if [ -z "${v}" ]; then
              echo "::error::Var obrigatÃ³ria ausente: ${k}"
              exit 1
            fi
          done

          if [ -z "${{ secrets.PEM_KEY }}" ]; then
            echo "::error::Secret obrigatÃ³rio ausente: PEM_KEY"
            exit 1
          fi

          # default: PORT (porta do container)
          if [ -z "${PORT:-}" ]; then
            PORT="80"
          fi

          if ! echo "${HOST_PORT}" | grep -Eq '^[0-9]+$'; then
            echo "::error::HOST_PORT invÃ¡lido: ${HOST_PORT}"
            exit 1
          fi
          if ! echo "${PORT}" | grep -Eq '^[0-9]+$'; then
            echo "::error::PORT invÃ¡lido: ${PORT}"
            exit 1
          fi

          if ! [[ "${PACKAGE_MANAGER}" =~ ^(npm|yarn|pnpm)$ ]]; then
            echo "::error::PACKAGE_MANAGER invÃ¡lido: ${PACKAGE_MANAGER} (use npm|yarn|pnpm)"
            exit 1
          fi

          if ! echo "${IMAGE_RETENTION_COUNT}" | grep -Eq '^[1-9][0-9]*$'; then
            echo "::error::IMAGE_RETENTION_COUNT deve ser inteiro > 0"
            exit 1
          fi

          echo "PORT=${PORT}" >> "$GITHUB_ENV"

      - name: "ðŸ›’ Checkout"
        uses: actions/checkout@v6

      - name: "ðŸ§° Setup Node"
        if: ${{ env.CACHE_DEPENDENCY_PATH == '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: ${{ env.PACKAGE_MANAGER }}

      - name: "ðŸ§° Setup Node (cache custom path)"
        if: ${{ env.CACHE_DEPENDENCY_PATH != '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: ${{ env.PACKAGE_MANAGER }}
          cache-dependency-path: ${{ env.CACHE_DEPENDENCY_PATH }}

      - name: "ðŸ”Ž Debug: o que vai pro container (vars em claro)"
        env:
          VARS_JSON: ${{ toJSON(vars) }}
          SECRETS_JSON: ${{ toJSON(secrets) }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const vars = JSON.parse(process.env.VARS_JSON || '{}');
          const secrets = JSON.parse(process.env.SECRETS_JSON || '{}');

          const out = {};
          const src = {};
          const norm = (k) => k.startsWith('ENV_') ? k.slice(4) : k;

          for (const [k, v] of Object.entries(vars)) {
            if (v == null) continue;
            const kk = norm(k);
            if (!kk) continue;
            out[kk] = String(v);
            src[kk] = 'var(' + k + ')';
          }

          for (const [k, v] of Object.entries(secrets)) {
            if (!k.startsWith('ENV_') || v == null) continue;
            const kk = k.slice(4);
            if (!kk) continue;
            out[kk] = String(v);
            src[kk] = 'secret(' + k + ')';
          }

          const keys = Object.keys(out).sort();
          console.log('--- ENV efetivas (container) ---');
          if (!keys.length) console.log('(nenhuma env encontrada)');
          for (const k of keys) {
            const from = src[k] || '?';
            const val = from.startsWith('secret(') ? '*** (secret)' : JSON.stringify(out[k]);
            console.log(k + ' = ' + val + '  <= ' + from);
          }
          console.log('-------------------------------');

          const hostPort = out.HOST_PORT;
          const port = out.PORT || '80';
          console.log('PORT MAP: -p ' + hostPort + ':' + port);
          NODE

      - name: "ðŸ§¾ Gerar .runtime.env (vars: tudo | secrets: sÃ³ ENV_*)"
        env:
          VARS_JSON: ${{ toJSON(vars) }}
          SECRETS_JSON: ${{ toJSON(secrets) }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const fs = require('fs');

          const vars = JSON.parse(process.env.VARS_JSON || '{}');
          const secrets = JSON.parse(process.env.SECRETS_JSON || '{}');

          const out = {};
          const norm = (k) => k.startsWith('ENV_') ? k.slice(4) : k;

          for (const [k, v] of Object.entries(vars)) {
            if (v == null) continue;
            const kk = norm(k);
            if (!kk) continue;
            out[kk] = String(v);
          }

          for (const [k, v] of Object.entries(secrets)) {
            if (!k.startsWith('ENV_') || v == null) continue;
            const kk = k.slice(4);
            if (!kk) continue;
            out[kk] = String(v);
          }

          if (!('PORT' in out) || String(out.PORT).trim() === '') out.PORT = '80';

          const safe = {};
          for (const [k, v] of Object.entries(out)) {
            if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(k)) safe[k] = v;
          }

          const content = Object.keys(safe).sort().map(k => k + '=' + safe[k]).join('\n');
          fs.writeFileSync('.runtime.env', content ? content + '\n' : '');
          NODE
          chmod 600 .runtime.env

      - name: "ðŸ› ï¸ Install"
        run: ${{ env.INSTALL_CMD }}

      - name: "ðŸ—ï¸ Build"
        run: ${{ env.BUILD_CMD }}

      - name: "ðŸ”¢ Version"
        id: version
        run: |
          set -euo pipefail
          VERSION="$(bash -lc "${VERSION_CMD}")"
          if [ -z "${VERSION}" ]; then
            echo "::error::VERSION_CMD retornou vazio"
            exit 1
          fi
          echo "VERSION=${VERSION}" >> "$GITHUB_ENV"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"

      - name: "ðŸªª Image metadata"
        id: image_metadata
        run: |
          set -euo pipefail
          IMAGE_REF="${REGISTRY}/${IMAGE_NAMESPACE}/${DOCKER_IMAGE}:${VERSION}"
          echo "IMAGE_REF=${IMAGE_REF}" >> "$GITHUB_ENV"
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"

      - name: "ðŸ” known_hosts"
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          if [ -n "${SSH_KNOWN_HOSTS:-}" ]; then
            printf '%s\n' "${SSH_KNOWN_HOSTS}" >> ~/.ssh/known_hosts
          fi

          ssh-keyscan -T 10 -H -p "${SSH_REMOTE_PORT}" "${SSH_HOST}" >> ~/.ssh/known_hosts
          sort -u ~/.ssh/known_hosts -o ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: "ðŸ”‘ SSH key"
        run: |
          set -euo pipefail
          printf '%s\n' "${{ secrets.PEM_KEY }}" > ./deploy-key.pem
          chmod 600 ./deploy-key.pem

      - name: "ðŸ—ï¸ Docker Buildx"
        uses: docker/setup-buildx-action@v3

      - name: "ðŸ³ Docker login"
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: "ðŸ³ Build & Push"
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.DOCKER_IMAGE }}:${{ env.VERSION }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.DOCKER_IMAGE }}:latest
          platforms: ${{ env.DOCKER_PLATFORM }}
          build-args: ${{ env.DOCKER_BUILD_ARGS }}
          cache-from: type=gha,scope=${{ env.DOCKER_IMAGE }}
          cache-to: type=gha,mode=max,scope=${{ env.DOCKER_IMAGE }}
          provenance: true
          sbom: true
          labels: |
            org.opencontainers.image.title=${{ env.PROJECT_NAME }}
            org.opencontainers.image.version=${{ env.VERSION }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.created=${{ github.run_started_at }}

      - name: "ðŸš€ Deploy remoto"
        run: |
          set -euo pipefail

          IMAGE_REF="${REGISTRY}/${IMAGE_NAMESPACE}/${DOCKER_IMAGE}:${VERSION}"
          REPOSITORY="${REGISTRY}/${IMAGE_NAMESPACE}/${DOCKER_IMAGE}"
          DEPLOY_HOST_PORT="${HOST_PORT:-}"
          DEPLOY_PORT="${PORT:-80}"

          SERVICE_NAME="${CONTAINER_NAME:-}"
          if [ -z "${SERVICE_NAME}" ]; then
            SERVICE_NAME="${DOCKER_IMAGE}"
          fi

          ENV_B64=""
          if [ -s ".runtime.env" ]; then
            ENV_B64="$(base64 -w0 .runtime.env 2>/dev/null || base64 .runtime.env | tr -d '\n')"
          fi

          if [ -z "${DEPLOY_HOST_PORT}" ]; then
            echo "::error::HOST_PORT ausente no ambiente do job."
            exit 1
          fi
          if ! echo "${DEPLOY_HOST_PORT}" | grep -Eq '^[0-9]+$'; then
            echo "::error::HOST_PORT invÃ¡lido: ${DEPLOY_HOST_PORT}"
            exit 1
          fi
          if ! echo "${DEPLOY_PORT}" | grep -Eq '^[0-9]+$'; then
            echo "::error::PORT invÃ¡lido: ${DEPLOY_PORT}"
            exit 1
          fi

          ssh -o StrictHostKeyChecking=yes \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              -o ConnectTimeout=10 \
              -p "${SSH_REMOTE_PORT}" \
              -i ./deploy-key.pem \
              "${SSH_USER}@${SSH_HOST}" \
              env \
              DOCKER_USERNAME="${DOCKER_USERNAME}" \
              DOCKER_PASSWORD="${DOCKER_PASSWORD}" \
              REGISTRY="${REGISTRY}" \
              IMAGE_REF="${IMAGE_REF}" \
              REPOSITORY="${REPOSITORY}" \
              KEEP_IMAGES="${IMAGE_RETENTION_COUNT}" \
              SERVICE_NAME="${SERVICE_NAME}" \
              HOST_PORT="${DEPLOY_HOST_PORT}" \
              PORT="${DEPLOY_PORT}" \
              ENV_B64="${ENV_B64}" \
              REMOTE_DOCKER_LOGIN="${REMOTE_DOCKER_LOGIN}" \
              HEALTHCHECK_URL="${HEALTHCHECK_URL}" \
              HEALTHCHECK_RETRIES="${HEALTHCHECK_RETRIES}" \
              HEALTHCHECK_DELAY="${HEALTHCHECK_DELAY}" \
              bash -s << 'EOF'
            set -euo pipefail

            TMP_ENV_FILE=""
            cleanup() { [ -n "${TMP_ENV_FILE}" ] && [ -f "${TMP_ENV_FILE}" ] && rm -f "${TMP_ENV_FILE}"; }
            trap cleanup EXIT

            if [ -n "${ENV_B64}" ]; then
              TMP_ENV_FILE="$(mktemp)"
              printf '%s' "${ENV_B64}" | base64 -d > "${TMP_ENV_FILE}"
            else
              echo "Env-file nÃ£o chegou no servidor."
              exit 1
            fi

            [ -z "${PORT:-}" ] && PORT="80"

            if [ -z "${HOST_PORT:-}" ]; then
              echo "HOST_PORT ausente no ambiente remoto (env do SSH)."
              exit 1
            fi
            if ! echo "${HOST_PORT}" | grep -Eq '^[0-9]+$'; then
              echo "HOST_PORT invÃ¡lido: '${HOST_PORT}'"
              exit 1
            fi
            if ! echo "${PORT}" | grep -Eq '^[0-9]+$'; then
              echo "PORT invÃ¡lido: '${PORT}'"
              exit 1
            fi

            PORT_OPT="-p ${HOST_PORT}:${PORT}"
            ENV_OPT="--env-file ${TMP_ENV_FILE}"

            PREVIOUS_IMAGE_ID="$(docker inspect -f '{{.Image}}' "${SERVICE_NAME}" 2>/dev/null || true)"

            if [ "${REMOTE_DOCKER_LOGIN}" = "true" ]; then
              echo "${DOCKER_PASSWORD}" | docker login "${REGISTRY}" -u "${DOCKER_USERNAME}" --password-stdin
            fi

            docker pull "${IMAGE_REF}"

            docker stop "${SERVICE_NAME}" || true
            docker rm "${SERVICE_NAME}" || true

            if ! docker run -d --restart unless-stopped --name "${SERVICE_NAME}" \
              ${PORT_OPT} \
              ${ENV_OPT} \
              "${IMAGE_REF}"; then
              echo "Falha no deploy; rollback."
              if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                docker run -d --restart unless-stopped --name "${SERVICE_NAME}" \
                  ${PORT_OPT} \
                  ${ENV_OPT} \
                  "${PREVIOUS_IMAGE_ID}" || true
              fi
              exit 1
            fi

            sleep 5
            if ! docker ps --filter "name=${SERVICE_NAME}" --filter "status=running" --format '{{.ID}}' | grep -q .; then
              echo "Container nÃ£o estÃ¡ rodando; rollback."
              docker stop "${SERVICE_NAME}" || true
              docker rm "${SERVICE_NAME}" || true
              if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                docker run -d --restart unless-stopped --name "${SERVICE_NAME}" \
                  ${PORT_OPT} \
                  ${ENV_OPT} \
                  "${PREVIOUS_IMAGE_ID}" || true
              fi
              exit 1
            fi

            if [ -n "${HEALTHCHECK_URL}" ]; then
              if command -v curl >/dev/null 2>&1; then
                attempt=1
                success=0
                while [ $attempt -le "${HEALTHCHECK_RETRIES}" ]; do
                  if curl -fsSL --max-time 5 "${HEALTHCHECK_URL}"; then
                    success=1
                    break
                  fi
                  echo "Healthcheck falhou (${attempt}/${HEALTHCHECK_RETRIES}); aguardando ${HEALTHCHECK_DELAY}s"
                  attempt=$((attempt+1))
                  sleep "${HEALTHCHECK_DELAY}"
                done
                if [ $success -ne 1 ]; then
                  echo "Healthcheck nÃ£o passou; rollback."
                  docker stop "${SERVICE_NAME}" || true
                  docker rm "${SERVICE_NAME}" || true
                  if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                    docker run -d --restart unless-stopped --name "${SERVICE_NAME}" \
                      ${PORT_OPT} \
                      ${ENV_OPT} \
                      "${PREVIOUS_IMAGE_ID}" || true
                  fi
                  exit 1
                fi
              else
                echo "curl nÃ£o encontrado; pulando healthcheck."
              fi
            fi

            OLD_IMAGE_IDS="$(docker image ls "${REPOSITORY}" --format '{{.CreatedAt}} {{.ID}}' | sort -r | awk "NR>${KEEP_IMAGES}{print \$2}")"
            if [ -n "${OLD_IMAGE_IDS}" ]; then
              echo "${OLD_IMAGE_IDS}" | xargs -r docker image rm -f || true
            fi
            docker image prune -f >/dev/null 2>&1 || true
          EOF

      - name: "ðŸ§¹ Remover chave SSH"
        if: always()
        run: rm -f ./deploy-key.pem

      - name: "ðŸ§¹ Limpar runner"
        if: ${{ always() && env.PRUNE_RUNNER == 'true' }}
        run: docker system prune -af --volumes || true

      - name: "ðŸ“ Summary"
        if: always()
        run: |
          {
            echo "## Deploy Docker"
            echo "- Projeto: ${PROJECT_NAME}"
            echo "- Ambiente: ${ENVIRONMENT}"
            echo "- Imagem: ${REGISTRY}/${IMAGE_NAMESPACE}/${DOCKER_IMAGE}:${VERSION}"
            echo "- Portas: ${HOST_PORT}:${PORT}"
            echo "- RetenÃ§Ã£o: ${IMAGE_RETENTION_COUNT}"
          } >> "$GITHUB_STEP_SUMMARY"
