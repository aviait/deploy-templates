name: Deploy Docker Project Template v2

on:
  workflow_call:
    inputs:
      ENVIRONMENT:
        required: true
        type: string
      PROJECT_NAME:
        required: true
        type: string
      SSH_USER:
        required: true
        type: string
      SSH_HOST:
        required: true
        type: string
      SSH_KNOWN_HOSTS:
        required: false
        type: string
        default: ""
      REQUIRE_SSH_KNOWN_HOSTS:
        required: false
        type: boolean
        default: false
      SSH_REMOTE_PORT:
        required: false
        type: number
        default: 22
      DOCKER_IMAGE:
        required: true
        type: string
      CONTAINER_NAME:
        required: false
        type: string
        default: ""
      REGISTRY:
        required: false
        type: string
        default: docker.io
      IMAGE_NAMESPACE:
        required: false
        type: string
        default: ""
      HOST_PORT:
        required: true
        type: number
      PORT:
        required: false
        type: number
        default: 80
      NODE_VERSION:
        required: false
        type: string
        default: "22"
      PACKAGE_MANAGER:
        required: false
        type: string
        default: "yarn"
      INSTALL_CMD:
        required: false
        type: string
        default: "yarn install --immutable"
      BUILD_CMD:
        required: false
        type: string
        default: "yarn build"
      VERSION_CMD:
        required: false
        type: string
        default: "node -p \"require('./package.json').version\""
      CACHE_DEPENDENCY_PATH:
        required: false
        type: string
        default: ""
      DOCKER_PLATFORM:
        required: false
        type: string
        default: linux/amd64
      DOCKER_BUILD_ARGS:
        required: false
        type: string
        default: ""
      IMAGE_RETENTION_COUNT:
        required: false
        type: number
        default: 5
      REMOTE_DOCKER_LOGIN:
        required: false
        type: boolean
        default: true
      HEALTHCHECK_URL:
        required: false
        type: string
        default: ""
      HEALTHCHECK_RETRIES:
        required: false
        type: number
        default: 12
      HEALTHCHECK_DELAY:
        required: false
        type: number
        default: 5
      PRUNE_RUNNER:
        required: false
        type: boolean
        default: true
    secrets:
      PEM_KEY:
        required: true
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true

jobs:
  deploy:
    name: "ðŸš€ Deploy ${{ inputs.PROJECT_NAME }} (${{ inputs.ENVIRONMENT }})"
    runs-on: ubuntu-latest
    timeout-minutes: 30

    concurrency:
      group: deploy-docker-${{ inputs.PROJECT_NAME }}-${{ inputs.ENVIRONMENT }}
      cancel-in-progress: true

    permissions:
      contents: read

    environment: ${{ inputs.ENVIRONMENT }}

    defaults:
      run:
        shell: bash

    outputs:
      version: ${{ steps.version.outputs.version }}
      image_ref: ${{ steps.image_metadata.outputs.image_ref }}

    env:
      PROJECT_NAME: ${{ inputs.PROJECT_NAME }}
      ENVIRONMENT: ${{ inputs.ENVIRONMENT }}

      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      REGISTRY: ${{ inputs.REGISTRY != '' && inputs.REGISTRY || 'docker.io' }}
      IMAGE_NAMESPACE: ${{ inputs.IMAGE_NAMESPACE != '' && inputs.IMAGE_NAMESPACE || secrets.DOCKER_USERNAME }}

      SSH_USER: ${{ inputs.SSH_USER }}
      SSH_HOST: ${{ inputs.SSH_HOST }}
      SSH_REMOTE_PORT: ${{ inputs.SSH_REMOTE_PORT }}
      SSH_KNOWN_HOSTS: ${{ inputs.SSH_KNOWN_HOSTS }}
      REQUIRE_SSH_KNOWN_HOSTS: ${{ inputs.REQUIRE_SSH_KNOWN_HOSTS && 'true' || 'false' }}

      DOCKER_IMAGE: ${{ inputs.DOCKER_IMAGE }}
      CONTAINER_NAME: ${{ inputs.CONTAINER_NAME }}

      HOST_PORT: ${{ inputs.HOST_PORT }}
      PORT: ${{ inputs.PORT }}

      NODE_VERSION: ${{ inputs.NODE_VERSION }}
      PACKAGE_MANAGER: ${{ inputs.PACKAGE_MANAGER }}
      INSTALL_CMD: ${{ inputs.INSTALL_CMD }}
      BUILD_CMD: ${{ inputs.BUILD_CMD }}
      VERSION_CMD: ${{ inputs.VERSION_CMD }}
      CACHE_DEPENDENCY_PATH: ${{ inputs.CACHE_DEPENDENCY_PATH }}

      DOCKER_PLATFORM: ${{ inputs.DOCKER_PLATFORM }}
      DOCKER_BUILD_ARGS: ${{ inputs.DOCKER_BUILD_ARGS }}

      IMAGE_RETENTION_COUNT: ${{ inputs.IMAGE_RETENTION_COUNT }}
      REMOTE_DOCKER_LOGIN: ${{ inputs.REMOTE_DOCKER_LOGIN && 'true' || 'false' }}
      HEALTHCHECK_URL: ${{ inputs.HEALTHCHECK_URL }}
      HEALTHCHECK_RETRIES: ${{ inputs.HEALTHCHECK_RETRIES }}
      HEALTHCHECK_DELAY: ${{ inputs.HEALTHCHECK_DELAY }}

      PRUNE_RUNNER: ${{ inputs.PRUNE_RUNNER && 'true' || 'false' }}

    steps:
      - name: "âœ… ValidaÃ§Ã£o prÃ©via (obrigatÃ³rios)"
        run: |
          set -euo pipefail

          req_vars=(PROJECT_NAME ENVIRONMENT DOCKER_IMAGE SSH_USER SSH_HOST DOCKER_USERNAME DOCKER_PASSWORD HOST_PORT IMAGE_NAMESPACE)

          for k in "${req_vars[@]}"; do
            v="${!k:-}"
            if [ -z "${v}" ]; then
              echo "::error::Valor obrigatÃ³rio ausente: ${k}"
              exit 1
            fi
          done

          if [ -z "${{ secrets.PEM_KEY }}" ]; then
            echo "::error::Secret obrigatÃ³rio ausente: PEM_KEY"
            exit 1
          fi

          if ! echo "${HOST_PORT}" | grep -Eq '^[0-9]+$'; then
            echo "::error::HOST_PORT invÃ¡lido: ${HOST_PORT}"
            exit 1
          fi
          if ! echo "${PORT}" | grep -Eq '^[0-9]+$'; then
            echo "::error::PORT invÃ¡lido: ${PORT}"
            exit 1
          fi

          if ! [[ "${PACKAGE_MANAGER}" =~ ^(npm|yarn|pnpm)$ ]]; then
            echo "::error::PACKAGE_MANAGER invÃ¡lido: ${PACKAGE_MANAGER} (use npm|yarn|pnpm)"
            exit 1
          fi

          if ! echo "${IMAGE_RETENTION_COUNT}" | grep -Eq '^[1-9][0-9]*$'; then
            echo "::error::IMAGE_RETENTION_COUNT deve ser inteiro > 0"
            exit 1
          fi

          if ! echo "${HEALTHCHECK_RETRIES}" | grep -Eq '^[1-9][0-9]*$'; then
            echo "::error::HEALTHCHECK_RETRIES deve ser inteiro > 0"
            exit 1
          fi

          if ! echo "${HEALTHCHECK_DELAY}" | grep -Eq '^[0-9]+$'; then
            echo "::error::HEALTHCHECK_DELAY deve ser inteiro >= 0"
            exit 1
          fi

          if [ "${REQUIRE_SSH_KNOWN_HOSTS}" = "true" ] && [ -z "${SSH_KNOWN_HOSTS}" ]; then
            echo "::error::REQUIRE_SSH_KNOWN_HOSTS=true exige SSH_KNOWN_HOSTS preenchido."
            exit 1
          fi

      - name: "ðŸ›’ Checkout"
        uses: actions/checkout@v6

      - name: "ðŸ§° Setup Node"
        if: ${{ env.CACHE_DEPENDENCY_PATH == '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: ${{ env.PACKAGE_MANAGER }}

      - name: "ðŸ§° Setup Node (cache custom path)"
        if: ${{ env.CACHE_DEPENDENCY_PATH != '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: ${{ env.PACKAGE_MANAGER }}
          cache-dependency-path: ${{ env.CACHE_DEPENDENCY_PATH }}

      - name: "ðŸ”Ž Debug: ENV_* que irÃ£o para o container"
        env:
          VARS_JSON: ${{ toJSON(vars) }}
          SECRETS_JSON: ${{ toJSON(secrets) }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const vars = JSON.parse(process.env.VARS_JSON || '{}');
          const secrets = JSON.parse(process.env.SECRETS_JSON || '{}');

          const out = {};
          const src = {};

          for (const [k, v] of Object.entries(vars)) {
            if (!k.startsWith('ENV_') || v == null) continue;
            const kk = k.slice(4);
            if (!kk) continue;
            out[kk] = String(v);
            src[kk] = 'var(' + k + ')';
          }

          for (const [k, v] of Object.entries(secrets)) {
            if (!k.startsWith('ENV_') || v == null) continue;
            const kk = k.slice(4);
            if (!kk) continue;
            out[kk] = String(v);
            src[kk] = 'secret(' + k + ')';
          }

          const keys = Object.keys(out).sort();
          console.log('--- ENV efetivas (container) ---');
          if (!keys.length) console.log('(nenhuma env ENV_* encontrada)');
          for (const k of keys) {
            const from = src[k] || '?';
            const val = from.startsWith('secret(') ? '*** (secret)' : JSON.stringify(out[k]);
            console.log(k + ' = ' + val + '  <= ' + from);
          }
          console.log('-------------------------------');
          console.log('PORT MAP: -p ' + process.env.HOST_PORT + ':' + process.env.PORT);
          NODE

      - name: "ðŸ§¾ Gerar .runtime.env (somente ENV_*)"
        env:
          VARS_JSON: ${{ toJSON(vars) }}
          SECRETS_JSON: ${{ toJSON(secrets) }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const fs = require('fs');

          const vars = JSON.parse(process.env.VARS_JSON || '{}');
          const secrets = JSON.parse(process.env.SECRETS_JSON || '{}');

          const out = {};

          for (const [k, v] of Object.entries(vars)) {
            if (!k.startsWith('ENV_') || v == null) continue;
            const kk = k.slice(4);
            if (!kk) continue;
            out[kk] = String(v);
          }

          for (const [k, v] of Object.entries(secrets)) {
            if (!k.startsWith('ENV_') || v == null) continue;
            const kk = k.slice(4);
            if (!kk) continue;
            out[kk] = String(v);
          }

          if (!('PORT' in out) || String(out.PORT).trim() === '') out.PORT = process.env.PORT || '80';

          const safe = {};
          const skipped = [];
          for (const [k, v] of Object.entries(out)) {
            if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(k)) continue;
            if (/[\u0000\r\n]/.test(v)) {
              skipped.push(k);
              continue;
            }
            safe[k] = v;
          }

          if (skipped.length) {
            console.log('Ignoradas no .runtime.env (valor invÃ¡lido para --env-file): ' + skipped.sort().join(', '));
          }

          const content = Object.keys(safe).sort().map((k) => k + '=' + safe[k]).join('\n');
          fs.writeFileSync('.runtime.env', content ? content + '\n' : '');
          NODE
          chmod 600 .runtime.env

      - name: "ðŸ› ï¸ Install"
        run: ${{ env.INSTALL_CMD }}

      - name: "ðŸ—ï¸ Build"
        run: ${{ env.BUILD_CMD }}

      - name: "ðŸ”¢ Version"
        id: version
        run: |
          set -euo pipefail
          VERSION="$(bash -lc "${VERSION_CMD}")"
          if [ -z "${VERSION}" ]; then
            echo "::error::VERSION_CMD retornou vazio"
            exit 1
          fi
          echo "VERSION=${VERSION}" >> "$GITHUB_ENV"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"

      - name: "ðŸªª Image metadata"
        id: image_metadata
        run: |
          set -euo pipefail
          IMAGE_REF="${REGISTRY}/${IMAGE_NAMESPACE}/${DOCKER_IMAGE}:${VERSION}"
          echo "IMAGE_REF=${IMAGE_REF}" >> "$GITHUB_ENV"
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"

      - name: "ðŸ” known_hosts"
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          if [ -n "${SSH_KNOWN_HOSTS}" ]; then
            printf '%s\n' "${SSH_KNOWN_HOSTS}" >> ~/.ssh/known_hosts
          fi

          if [ "${REQUIRE_SSH_KNOWN_HOSTS}" != "true" ]; then
            ssh-keyscan -T 10 -H -p "${SSH_REMOTE_PORT}" "${SSH_HOST}" >> ~/.ssh/known_hosts
          fi

          sort -u ~/.ssh/known_hosts -o ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: "ðŸ”‘ SSH key"
        run: |
          set -euo pipefail
          printf '%s\n' "${{ secrets.PEM_KEY }}" > ./deploy-key.pem
          chmod 600 ./deploy-key.pem

      - name: "ðŸ—ï¸ Docker Buildx"
        uses: docker/setup-buildx-action@v3

      - name: "ðŸ³ Docker login"
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: "ðŸ³ Build & Push"
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.DOCKER_IMAGE }}:${{ env.VERSION }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.DOCKER_IMAGE }}:latest
          platforms: ${{ env.DOCKER_PLATFORM }}
          build-args: ${{ env.DOCKER_BUILD_ARGS }}
          cache-from: type=gha,scope=${{ env.DOCKER_IMAGE }}
          cache-to: type=gha,mode=max,scope=${{ env.DOCKER_IMAGE }}
          provenance: true
          sbom: true
          labels: |
            org.opencontainers.image.title=${{ env.PROJECT_NAME }}
            org.opencontainers.image.version=${{ env.VERSION }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.created=${{ github.run_started_at }}

      - name: "ðŸš€ Deploy remoto"
        run: |
          set -euo pipefail

          IMAGE_REF="${REGISTRY}/${IMAGE_NAMESPACE}/${DOCKER_IMAGE}:${VERSION}"
          REPOSITORY="${REGISTRY}/${IMAGE_NAMESPACE}/${DOCKER_IMAGE}"
          DEPLOY_HOST_PORT="${HOST_PORT:-}"
          DEPLOY_PORT="${PORT:-80}"

          SERVICE_NAME="${CONTAINER_NAME:-}"
          if [ -z "${SERVICE_NAME}" ]; then
            SERVICE_NAME="${DOCKER_IMAGE}"
          fi

          ENV_B64=""
          if [ -s ".runtime.env" ]; then
            ENV_B64="$(base64 -w0 .runtime.env 2>/dev/null || base64 .runtime.env | tr -d '\n')"
          fi

          if [ -z "${DEPLOY_HOST_PORT}" ]; then
            echo "::error::HOST_PORT ausente no ambiente do job."
            exit 1
          fi
          if ! echo "${DEPLOY_HOST_PORT}" | grep -Eq '^[0-9]+$'; then
            echo "::error::HOST_PORT invÃ¡lido: ${DEPLOY_HOST_PORT}"
            exit 1
          fi
          if ! echo "${DEPLOY_PORT}" | grep -Eq '^[0-9]+$'; then
            echo "::error::PORT invÃ¡lido: ${DEPLOY_PORT}"
            exit 1
          fi

          ssh -o StrictHostKeyChecking=yes \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              -o ConnectTimeout=10 \
              -p "${SSH_REMOTE_PORT}" \
              -i ./deploy-key.pem \
              "${SSH_USER}@${SSH_HOST}" \
              env \
              DOCKER_USERNAME="${DOCKER_USERNAME}" \
              DOCKER_PASSWORD="${DOCKER_PASSWORD}" \
              REGISTRY="${REGISTRY}" \
              IMAGE_REF="${IMAGE_REF}" \
              REPOSITORY="${REPOSITORY}" \
              KEEP_IMAGES="${IMAGE_RETENTION_COUNT}" \
              SERVICE_NAME="${SERVICE_NAME}" \
              HOST_PORT="${DEPLOY_HOST_PORT}" \
              PORT="${DEPLOY_PORT}" \
              ENV_B64="${ENV_B64}" \
              REMOTE_DOCKER_LOGIN="${REMOTE_DOCKER_LOGIN}" \
              HEALTHCHECK_URL="${HEALTHCHECK_URL}" \
              HEALTHCHECK_RETRIES="${HEALTHCHECK_RETRIES}" \
              HEALTHCHECK_DELAY="${HEALTHCHECK_DELAY}" \
              bash -s << 'EOF'
            set -euo pipefail

            TMP_ENV_FILE=""
            cleanup() { [ -n "${TMP_ENV_FILE}" ] && [ -f "${TMP_ENV_FILE}" ] && rm -f "${TMP_ENV_FILE}"; }
            trap cleanup EXIT

            if [ -n "${ENV_B64}" ]; then
              TMP_ENV_FILE="$(mktemp)"
              printf '%s' "${ENV_B64}" | base64 -d > "${TMP_ENV_FILE}"
            else
              echo "Env-file nÃ£o chegou no servidor."
              exit 1
            fi

            [ -z "${PORT:-}" ] && PORT="80"

            if [ -z "${HOST_PORT:-}" ]; then
              echo "HOST_PORT ausente no ambiente remoto (env do SSH)."
              exit 1
            fi
            if ! echo "${HOST_PORT}" | grep -Eq '^[0-9]+$'; then
              echo "HOST_PORT invÃ¡lido: '${HOST_PORT}'"
              exit 1
            fi
            if ! echo "${PORT}" | grep -Eq '^[0-9]+$'; then
              echo "PORT invÃ¡lido: '${PORT}'"
              exit 1
            fi

            PORT_OPT="-p ${HOST_PORT}:${PORT}"
            ENV_OPT="--env-file ${TMP_ENV_FILE}"

            PREVIOUS_IMAGE_ID="$(docker inspect -f '{{.Image}}' "${SERVICE_NAME}" 2>/dev/null || true)"

            if [ "${REMOTE_DOCKER_LOGIN}" = "true" ]; then
              echo "${DOCKER_PASSWORD}" | docker login "${REGISTRY}" -u "${DOCKER_USERNAME}" --password-stdin
            fi

            docker pull "${IMAGE_REF}"

            docker stop "${SERVICE_NAME}" || true
            docker rm "${SERVICE_NAME}" || true

            if ! docker run -d --restart unless-stopped --name "${SERVICE_NAME}" \
              ${PORT_OPT} \
              ${ENV_OPT} \
              "${IMAGE_REF}"; then
              echo "Falha no deploy; rollback."
              if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                docker run -d --restart unless-stopped --name "${SERVICE_NAME}" \
                  ${PORT_OPT} \
                  ${ENV_OPT} \
                  "${PREVIOUS_IMAGE_ID}" || true
              fi
              exit 1
            fi

            sleep 5
            if ! docker ps --filter "name=${SERVICE_NAME}" --filter "status=running" --format '{{.ID}}' | grep -q .; then
              echo "Container nÃ£o estÃ¡ rodando; rollback."
              docker stop "${SERVICE_NAME}" || true
              docker rm "${SERVICE_NAME}" || true
              if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                docker run -d --restart unless-stopped --name "${SERVICE_NAME}" \
                  ${PORT_OPT} \
                  ${ENV_OPT} \
                  "${PREVIOUS_IMAGE_ID}" || true
              fi
              exit 1
            fi

            if [ -n "${HEALTHCHECK_URL}" ]; then
              if command -v curl >/dev/null 2>&1; then
                attempt=1
                success=0
                while [ $attempt -le "${HEALTHCHECK_RETRIES}" ]; do
                  if curl -fsSL --max-time 5 "${HEALTHCHECK_URL}"; then
                    success=1
                    break
                  fi
                  echo "Healthcheck falhou (${attempt}/${HEALTHCHECK_RETRIES}); aguardando ${HEALTHCHECK_DELAY}s"
                  attempt=$((attempt+1))
                  sleep "${HEALTHCHECK_DELAY}"
                done
                if [ $success -ne 1 ]; then
                  echo "Healthcheck nÃ£o passou; rollback."
                  docker stop "${SERVICE_NAME}" || true
                  docker rm "${SERVICE_NAME}" || true
                  if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                    docker run -d --restart unless-stopped --name "${SERVICE_NAME}" \
                      ${PORT_OPT} \
                      ${ENV_OPT} \
                      "${PREVIOUS_IMAGE_ID}" || true
                  fi
                  exit 1
                fi
              else
                echo "curl nÃ£o encontrado; pulando healthcheck."
              fi
            fi

            OLD_IMAGE_IDS="$(docker image ls "${REPOSITORY}" --format '{{.CreatedAt}} {{.ID}}' | sort -r | awk "NR>${KEEP_IMAGES}{print \$2}")"
            if [ -n "${OLD_IMAGE_IDS}" ]; then
              echo "${OLD_IMAGE_IDS}" | xargs -r docker image rm -f || true
            fi
            docker image prune -f >/dev/null 2>&1 || true
          EOF

      - name: "ðŸ§¹ Remover chave SSH"
        if: always()
        run: rm -f ./deploy-key.pem

      - name: "ðŸ§¹ Limpar runner"
        if: ${{ always() && env.PRUNE_RUNNER == 'true' }}
        run: docker system prune -af --volumes || true

      - name: "ðŸ“ Summary"
        if: always()
        run: |
          {
            echo "## Deploy Docker"
            echo "- Projeto: ${PROJECT_NAME}"
            echo "- Ambiente: ${ENVIRONMENT}"
            echo "- Imagem: ${REGISTRY}/${IMAGE_NAMESPACE}/${DOCKER_IMAGE}:${VERSION}"
            echo "- Portas: ${HOST_PORT}:${PORT}"
            echo "- RetenÃ§Ã£o: ${IMAGE_RETENTION_COUNT}"
          } >> "$GITHUB_STEP_SUMMARY"
