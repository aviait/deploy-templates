name: v2 - Worker CI/CD

on:
  workflow_call:
    inputs:
      app_name:
        required: false
        type: string
        default: ""
      environment:
        required: true
        type: string
      working_directory:
        required: false
        type: string
        default: "."
      node_version:
        required: false
        type: string
        default: "20"
      package_manager:
        required: false
        type: string
        default: "npm"
      pnpm_version:
        required: false
        type: string
        default: "9"
      cache_dependency_path:
        required: false
        type: string
        default: ""
      lint_cmd:
        required: false
        type: string
        default: "npm run lint"
      typecheck_cmd:
        required: false
        type: string
        default: "npm run typecheck"
      test_cmd:
        required: false
        type: string
        default: "npm test -- --ci"
      dockerfile:
        required: false
        type: string
        default: "Dockerfile"
      registry:
        required: false
        type: string
        default: "ghcr.io"
      image_namespace:
        required: false
        type: string
        default: ""
      image_name:
        required: false
        type: string
        default: ""
      worker_name:
        required: false
        type: string
        default: ""
      ssh_user:
        required: false
        type: string
        default: ""
      ssh_host:
        required: false
        type: string
        default: ""
      ssh_remote_port:
        required: false
        type: number
        default: 0
      ssh_known_hosts:
        required: false
        type: string
        default: ""
      require_ssh_known_hosts:
        required: false
        type: boolean
        default: false
      worker_run_envs:
        required: false
        type: string
        default: ""
      worker_extra_args:
        required: false
        type: string
        default: ""
      remote_docker_login:
        required: false
        type: boolean
        default: true
      image_retention_count:
        required: false
        type: number
        default: 0
      startup_check_retries:
        required: false
        type: number
        default: 0
      startup_check_delay_seconds:
        required: false
        type: number
        default: -1
      prune_runner:
        required: false
        type: boolean
        default: true
      semver_prefix:
        required: false
        type: string
        default: "v"
      enable_release:
        required: false
        type: boolean
        default: true
      deploy_on_tag_only:
        required: false
        type: boolean
        default: false
      inject_all_github_vars:
        required: false
        type: boolean
        default: true
      github_vars_prefix:
        required: false
        type: string
        default: ""
      github_vars_exclude:
        required: false
        type: string
        default: ""
    secrets:
      CHECKOUT_TOKEN:
        required: false
      PEM_KEY:
        required: false
      DEPLOY_REGISTRY_USERNAME:
        required: false
      DEPLOY_REGISTRY_PASSWORD:
        required: false
      WORKER_RUN_ENVS_FILE:
        required: false

jobs:
  quality:
    name: quality
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working_directory }}
    steps:
      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.CHECKOUT_TOKEN || github.token }}

      - name: Setup Node
        if: ${{ inputs.cache_dependency_path == '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: Setup Node (custom cache path)
        if: ${{ inputs.cache_dependency_path != '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}
          cache-dependency-path: ${{ inputs.cache_dependency_path }}

      - name: Setup pnpm
        if: ${{ inputs.package_manager == 'pnpm' }}
        uses: pnpm/action-setup@v4
        with:
          version: ${{ inputs.pnpm_version }}

      - name: Install (reproducible)
        run: |
          set -euo pipefail
          case "${{ inputs.package_manager }}" in
            npm) npm ci ;;
            yarn) corepack enable && yarn install --immutable ;;
            pnpm) corepack enable && pnpm install --frozen-lockfile ;;
            *) echo "::error::PACKAGE_MANAGER inválido"; exit 1 ;;
          esac

      - run: ${{ inputs.lint_cmd }}
      - run: ${{ inputs.typecheck_cmd }}
      - run: ${{ inputs.test_cmd }}

  build:
    name: build
    needs: quality
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
    outputs:
      stage_image: ${{ steps.meta.outputs.stage_image }}
      release_image: ${{ steps.meta.outputs.release_image }}
      release_tag: ${{ steps.meta.outputs.release_tag }}
      registry: ${{ steps.meta.outputs.registry }}
    steps:
      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.CHECKOUT_TOKEN || github.token }}

      - name: Docker metadata
        id: meta
        run: |
          set -euo pipefail
          REF="${{ github.ref }}"
          EVENT_NAME="${{ github.event_name }}"
          REPO="${{ github.repository }}"
          SHA="${{ github.sha }}"

          REGISTRY_INPUT="${{ inputs.registry }}"
          if [ -z "${REGISTRY_INPUT}" ]; then
            REGISTRY_INPUT="ghcr.io"
          fi
          REGISTRY="${REGISTRY_INPUT,,}"

          IMAGE_INPUT="${{ inputs.image_name }}"
          if [ -z "${IMAGE_INPUT}" ]; then
            if [ "${REGISTRY}" = "ghcr.io" ]; then
              IMAGE_INPUT="${REPO}/worker"
            else
              IMAGE_INPUT="${REPO}"
            fi
          fi

          # Fail early on common misconfigurations that lead to "invalid reference format".
          if [ -z "${REGISTRY}" ]; then
            echo "::error::registry vazio"
            exit 1
          fi
          if printf '%s' "${REGISTRY}" | grep -Eq '://|/|[[:space:]]'; then
            echo "::error::registry invalido: '${REGISTRY}'. Use apenas o host (ex.: ghcr.io, docker.io, registry.exemplo.com:5000), sem 'https://' e sem '/'."
            exit 1
          fi

          if printf '%s' "${IMAGE_INPUT}" | grep -Eq '://|[[:space:]]'; then
            echo "::error::image_name invalido: '${IMAGE_INPUT}'. Nao use URL e nao use espacos."
            exit 1
          fi
          if printf '%s' "${IMAGE_INPUT}" | grep -Eq '[@:]'; then
            echo "::error::image_name nao deve conter tag/digest (':' ou '@'). Informe somente o repositorio (ex.: 'aviait/tei-worker' ou '${REPO}/worker')."
            exit 1
          fi
          FIRST_SEGMENT="${IMAGE_INPUT%%/*}"
          if [ "${FIRST_SEGMENT}" != "${IMAGE_INPUT}" ]; then
            if printf '%s' "${FIRST_SEGMENT}" | grep -Eq '[\\.:]' || [ "${FIRST_SEGMENT}" = "localhost" ]; then
              echo "::error::image_name nao deve incluir o registry host (ex.: 'ghcr.io/...'). Use o input registry para isso."
              exit 1
            fi
          fi

          NS_FROM_INPUT="${{ inputs.image_namespace }}"
          if [ -n "${NS_FROM_INPUT}" ] && printf '%s' "${NS_FROM_INPUT}" | grep -Eq '[:/@]|[[:space:]]'; then
            echo "::error::image_namespace invalido: '${NS_FROM_INPUT}'. Use apenas o namespace (ex.: aviait), sem '/', ':', '@' e sem espacos."
            exit 1
          fi

          IMAGE_PATH="${IMAGE_INPUT}"
          if ! printf '%s' "${IMAGE_PATH}" | grep -q '/'; then
            NS_INPUT="${{ inputs.image_namespace }}"
            if [ -n "${NS_INPUT}" ]; then
              IMAGE_PATH="${NS_INPUT}/${IMAGE_PATH}"
            else
              IMAGE_PATH="${REPO%%/*}/${IMAGE_PATH}"
            fi
          fi

          if [ "${REGISTRY}" = "docker.io" ]; then
            SLASH_COUNT="$(printf '%s' "${IMAGE_PATH}" | awk -F/ '{print NF-1}')"
            if [ "${SLASH_COUNT}" -ne 1 ]; then
              echo "::error::Para Docker Hub (docker.io), a imagem deve ser no formato 'namespace/repo'. Recebido: '${IMAGE_PATH}'."
              echo "::error::Sugestao: defina image_name como 'namespace/repo' (ex.: 'aviait/tei-worker') e opcionalmente use image_namespace."
              exit 1
            fi
          fi

          IMAGE="${REGISTRY}/${IMAGE_PATH}"
          IMAGE="${IMAGE,,}"
          SHA_TAG="sha-${SHA::12}"
          STAGE_IMAGE="${IMAGE}:${SHA_TAG}"
          RELEASE_TAG=""
          RELEASE_IMAGE=""
          PUSH_IMAGE="true"

          if [ "${EVENT_NAME}" = "pull_request" ]; then
            PUSH_IMAGE="false"
          fi

          if [[ "${REF}" == refs/tags/${{ inputs.semver_prefix }}* ]]; then
            GIT_TAG="${REF#refs/tags/}"
            PKG_JSON="${{ inputs.working_directory }}/package.json"

            PACKAGE_VERSION=""
            if [ -f "${PKG_JSON}" ]; then
              PACKAGE_VERSION="$(python3 -c "import json,sys; print(str(json.load(open(sys.argv[1], encoding='utf-8')).get('version','')).strip())" "${PKG_JSON}" 2>/dev/null || true)"
            fi

            if [ -n "${PACKAGE_VERSION}" ]; then
              PREFIX="${{ inputs.semver_prefix }}"
              if [ "${GIT_TAG}" != "${PREFIX}${PACKAGE_VERSION}" ] && [ "${GIT_TAG}" != "${PACKAGE_VERSION}" ]; then
                echo "::error::Tag '${GIT_TAG}' nao corresponde a versao do package.json ('${PACKAGE_VERSION}'). Esperado '${PREFIX}${PACKAGE_VERSION}'."
                exit 1
              fi
              RELEASE_TAG="${PACKAGE_VERSION}"
            else
              echo "::warning::Nao foi possivel ler package.json version em '${PKG_JSON}'. Usando tag git como release_tag."
              RELEASE_TAG="${GIT_TAG}"
            fi

            RELEASE_IMAGE="${IMAGE}:${RELEASE_TAG}"
          fi

          {
            echo "registry=${REGISTRY}"
            echo "stage_image=${STAGE_IMAGE}"
            echo "release_image=${RELEASE_IMAGE}"
            echo "release_tag=${RELEASE_TAG}"
            echo "push_image=${PUSH_IMAGE}"
            echo "tags<<TAGLIST"
            echo "${STAGE_IMAGE}"
            echo "TAGLIST"
          } >> "$GITHUB_OUTPUT"

      - uses: docker/setup-buildx-action@v3

      - name: Validate registry credentials (non-GHCR)
        if: ${{ steps.meta.outputs.push_image == 'true' && steps.meta.outputs.registry != 'ghcr.io' }}
        env:
          DEPLOY_REGISTRY_USERNAME: ${{ secrets.DEPLOY_REGISTRY_USERNAME }}
          DEPLOY_REGISTRY_PASSWORD: ${{ secrets.DEPLOY_REGISTRY_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_REGISTRY_USERNAME:-}" ] || [ -z "${DEPLOY_REGISTRY_PASSWORD:-}" ]; then
            echo "::error::DEPLOY_REGISTRY_USERNAME/DEPLOY_REGISTRY_PASSWORD obrigatórios para publicar imagem quando registry != ghcr.io"
            exit 1
          fi

      - uses: docker/login-action@v3
        if: ${{ steps.meta.outputs.push_image == 'true' && steps.meta.outputs.registry != 'ghcr.io' }}
        with:
          registry: ${{ steps.meta.outputs.registry }}
          username: ${{ secrets.DEPLOY_REGISTRY_USERNAME }}
          password: ${{ secrets.DEPLOY_REGISTRY_PASSWORD }}

      - uses: docker/login-action@v3
        if: ${{ steps.meta.outputs.push_image == 'true' && steps.meta.outputs.registry == 'ghcr.io' }}
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Worker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.working_directory }}
          file: ${{ inputs.working_directory }}/${{ inputs.dockerfile }}
          push: ${{ steps.meta.outputs.push_image == 'true' }}
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha,scope=worker-env
          cache-to: type=gha,mode=max,scope=worker-env

      - name: Save image metadata
        run: |
          set -euo pipefail
          cat > "$RUNNER_TEMP/worker-image.json" <<JSON
          {
            "stage_image": "${{ steps.meta.outputs.stage_image }}",
            "release_image": "${{ steps.meta.outputs.release_image }}",
            "release_tag": "${{ steps.meta.outputs.release_tag }}",
            "git_sha": "${{ github.sha }}",
            "environment": "${{ inputs.environment }}"
          }
          JSON

      - uses: actions/upload-artifact@v4
        with:
          name: worker-image-metadata
          path: ${{ runner.temp }}/worker-image.json

  security:
    name: security
    needs: quality
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      actions: read
      security-events: write
    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working_directory }}
    steps:
      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.CHECKOUT_TOKEN || github.token }}

      - name: Setup Node
        if: ${{ inputs.cache_dependency_path == '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: Setup Node (custom cache path)
        if: ${{ inputs.cache_dependency_path != '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}
          cache-dependency-path: ${{ inputs.cache_dependency_path }}

      - name: Setup pnpm
        if: ${{ inputs.package_manager == 'pnpm' }}
        uses: pnpm/action-setup@v4
        with:
          version: ${{ inputs.pnpm_version }}

      - name: Install (reproducible)
        run: |
          set -euo pipefail
          case "${{ inputs.package_manager }}" in
            npm) npm ci ;;
            yarn) corepack enable && yarn install --immutable ;;
            pnpm) corepack enable && pnpm install --frozen-lockfile ;;
            *) echo "::error::PACKAGE_MANAGER inválido"; exit 1 ;;
          esac

      - name: Dependency audit
        run: |
          set -euo pipefail
          case "${{ inputs.package_manager }}" in
            npm) npm audit --audit-level=high ;;
            yarn)
              if yarn npm audit --all >/dev/null 2>&1; then
                yarn npm audit --all --recursive
              else
                yarn audit --level high
              fi
              ;;
            pnpm) pnpm audit --audit-level high ;;
            *) echo "::error::PACKAGE_MANAGER inválido"; exit 1 ;;
          esac

      - name: Secret scanning (gitleaks)
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript

      - name: CodeQL Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Analyze CodeQL
        uses: github/codeql-action/analyze@v3

  release:
    name: release
    if: ${{ inputs.enable_release && startsWith(github.ref, format('refs/tags/{0}', inputs.semver_prefix)) }}
    needs: [build, security]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
      packages: write
    outputs:
      release_image: ${{ steps.tag_image.outputs.release_image }}
    steps:
      - name: Validate registry credentials (non-GHCR)
        if: ${{ needs.build.outputs.registry != 'ghcr.io' }}
        env:
          DEPLOY_REGISTRY_USERNAME: ${{ secrets.DEPLOY_REGISTRY_USERNAME }}
          DEPLOY_REGISTRY_PASSWORD: ${{ secrets.DEPLOY_REGISTRY_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_REGISTRY_USERNAME:-}" ] || [ -z "${DEPLOY_REGISTRY_PASSWORD:-}" ]; then
            echo "::error::DEPLOY_REGISTRY_USERNAME/DEPLOY_REGISTRY_PASSWORD obrigatórios para publicar release quando registry != ghcr.io"
            exit 1
          fi

      - uses: docker/login-action@v3
        if: ${{ needs.build.outputs.registry != 'ghcr.io' }}
        with:
          registry: ${{ needs.build.outputs.registry }}
          username: ${{ secrets.DEPLOY_REGISTRY_USERNAME }}
          password: ${{ secrets.DEPLOY_REGISTRY_PASSWORD }}

      - uses: docker/login-action@v3
        if: ${{ needs.build.outputs.registry == 'ghcr.io' }}
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag and publish semver image
        id: tag_image
        run: |
          set -euo pipefail
          STAGE_IMAGE="${{ needs.build.outputs.stage_image }}"
          RELEASE_IMAGE="${{ needs.build.outputs.release_image }}"

          if [ -z "${RELEASE_IMAGE}" ]; then
            echo "::error::release_image vazio para tag de release"
            exit 1
          fi

          IMAGE_REPO="${RELEASE_IMAGE%:*}"
          GIT_TAG="${{ github.ref_name }}"
          GIT_RELEASE_IMAGE="${IMAGE_REPO}:${GIT_TAG}"
          docker pull "${STAGE_IMAGE}"
          docker tag "${STAGE_IMAGE}" "${RELEASE_IMAGE}"
          docker tag "${STAGE_IMAGE}" "${IMAGE_REPO}:latest"
          if [ "${GIT_RELEASE_IMAGE}" != "${RELEASE_IMAGE}" ]; then
            docker tag "${STAGE_IMAGE}" "${GIT_RELEASE_IMAGE}"
          fi
          docker push "${RELEASE_IMAGE}"
          docker push "${IMAGE_REPO}:latest"
          if [ "${GIT_RELEASE_IMAGE}" != "${RELEASE_IMAGE}" ]; then
            docker push "${GIT_RELEASE_IMAGE}"
          fi
          echo "release_image=${RELEASE_IMAGE}" >> "$GITHUB_OUTPUT"

      - uses: actions/download-artifact@v4
        with:
          name: worker-image-metadata
          path: ${{ runner.temp }}

      - uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: ${{ runner.temp }}/worker-image.json

  pre_deploy_config:
    name: pre-deploy-config
    if: ${{ always() && needs.build.result == 'success' && needs.security.result == 'success' && (needs.release.result == 'success' || needs.release.result == 'skipped') && github.event_name == 'pull_request' }}
    needs: [build, security, release]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
    steps:
      - name: Resolve deploy config (inputs + GitHub vars)
        id: resolve
        env:
          VARS_JSON: ${{ toJSON(vars) }}
          IN_APP_NAME: ${{ inputs.app_name != '' && inputs.app_name || github.event.repository.name || github.repository }}
          IN_SSH_USER: ${{ inputs.ssh_user }}
          IN_SSH_HOST: ${{ inputs.ssh_host }}
          IN_SSH_REMOTE_PORT: ${{ inputs.ssh_remote_port }}
          IN_SSH_KNOWN_HOSTS: ${{ inputs.ssh_known_hosts }}
          IN_REQUIRE_SSH_KNOWN_HOSTS: ${{ inputs.require_ssh_known_hosts }}
          IN_WORKER_NAME: ${{ inputs.worker_name }}
          IN_WORKER_RUN_ENVS: ${{ inputs.worker_run_envs }}
          IN_WORKER_EXTRA_ARGS: ${{ inputs.worker_extra_args }}
          IN_REMOTE_DOCKER_LOGIN: ${{ inputs.remote_docker_login }}
          IN_IMAGE_RETENTION_COUNT: ${{ inputs.image_retention_count }}
          IN_STARTUP_CHECK_RETRIES: ${{ inputs.startup_check_retries }}
          IN_STARTUP_CHECK_DELAY_SECONDS: ${{ inputs.startup_check_delay_seconds }}
          IN_PRUNE_RUNNER: ${{ inputs.prune_runner }}
          IN_INJECT_ALL_GITHUB_VARS: ${{ inputs.inject_all_github_vars }}
          IN_GITHUB_VARS_PREFIX: ${{ inputs.github_vars_prefix }}
          IN_GITHUB_VARS_EXCLUDE: ${{ inputs.github_vars_exclude }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const fs = require('fs');

          const vars = JSON.parse(process.env.VARS_JSON || '{}');

          const pickString = (...values) => {
            for (const v of values) {
              if (v === undefined || v === null) continue;
              const s = String(v).trim();
              if (s !== '') return s;
            }
            return '';
          };

          const pickPositiveInt = (fallback, ...values) => {
            for (const v of values) {
              if (v === undefined || v === null) continue;
              const s = String(v).trim();
              if (s === '' || s === '0') continue;
              const n = Number(s);
              if (Number.isFinite(n) && n > 0) return Math.floor(n);
            }
            return fallback;
          };

          const pickNonNegativeInt = (fallback, ...values) => {
            for (const v of values) {
              if (v === undefined || v === null) continue;
              const s = String(v).trim();
              if (s === '') continue;
              const n = Number(s);
              if (Number.isFinite(n) && n >= 0) return Math.floor(n);
            }
            return fallback;
          };

          const toBool = (v, fallback = false) => {
            if (v === undefined || v === null) return fallback;
            const s = String(v).trim().toLowerCase();
            if (s === '') return fallback;
            if (['1', 'true', 'yes', 'y', 'on'].includes(s)) return true;
            if (['0', 'false', 'no', 'n', 'off'].includes(s)) return false;
            return fallback;
          };

          const out = {
            app_name: pickString(process.env.IN_APP_NAME),
            ssh_user: pickString(process.env.IN_SSH_USER, vars.SSH_USER),
            ssh_host: pickString(process.env.IN_SSH_HOST, vars.SSH_HOST),
            ssh_remote_port: pickPositiveInt(22, process.env.IN_SSH_REMOTE_PORT, vars.SSH_REMOTE_PORT),
            ssh_known_hosts: pickString(process.env.IN_SSH_KNOWN_HOSTS, vars.SSH_KNOWN_HOSTS),
            require_ssh_known_hosts: toBool(process.env.IN_REQUIRE_SSH_KNOWN_HOSTS, false) || toBool(vars.REQUIRE_SSH_KNOWN_HOSTS, false),
            worker_name: pickString(process.env.IN_WORKER_NAME, vars.WORKER_NAME, process.env.IN_APP_NAME),
            worker_run_envs: pickString(process.env.IN_WORKER_RUN_ENVS, vars.WORKER_RUN_ENVS),
            worker_extra_args: pickString(process.env.IN_WORKER_EXTRA_ARGS, vars.WORKER_EXTRA_ARGS),
            remote_docker_login: toBool(process.env.IN_REMOTE_DOCKER_LOGIN, true),
            image_retention_count: pickPositiveInt(5, process.env.IN_IMAGE_RETENTION_COUNT, vars.IMAGE_RETENTION_COUNT),
            startup_check_retries: pickPositiveInt(6, process.env.IN_STARTUP_CHECK_RETRIES, vars.STARTUP_CHECK_RETRIES),
            startup_check_delay_seconds: pickNonNegativeInt(5, process.env.IN_STARTUP_CHECK_DELAY_SECONDS, vars.STARTUP_CHECK_DELAY_SECONDS),
            prune_runner: toBool(process.env.IN_PRUNE_RUNNER, true),
            inject_all_github_vars: toBool(process.env.IN_INJECT_ALL_GITHUB_VARS, true),
            github_vars_prefix: pickString(process.env.IN_GITHUB_VARS_PREFIX, vars.GITHUB_VARS_PREFIX),
            github_vars_exclude: pickString(process.env.IN_GITHUB_VARS_EXCLUDE, vars.GITHUB_VARS_EXCLUDE),
          };

          for (const [k, v] of Object.entries(out)) {
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `${k}=${String(v)}\n`);
          }
          NODE

      - name: Validate deploy config
        run: |
          set -euo pipefail
          [ -n "${{ steps.resolve.outputs.ssh_user }}" ] || { echo "::error::ssh_user ausente (input ou var SSH_USER)"; exit 1; }
          [ -n "${{ steps.resolve.outputs.ssh_host }}" ] || { echo "::error::ssh_host ausente (input ou var SSH_HOST)"; exit 1; }
          [ -n "${{ secrets.PEM_KEY }}" ] || { echo "::error::PEM_KEY ausente"; exit 1; }

          if [ "${{ steps.resolve.outputs.remote_docker_login }}" = "true" ] && { [ -z "${{ secrets.DEPLOY_REGISTRY_USERNAME }}" ] || [ -z "${{ secrets.DEPLOY_REGISTRY_PASSWORD }}" ]; }; then
            echo "::error::DEPLOY_REGISTRY_USERNAME/DEPLOY_REGISTRY_PASSWORD obrigatórios quando remote_docker_login=true"
            exit 1
          fi

          if [ "${{ steps.resolve.outputs.require_ssh_known_hosts }}" = "true" ] && [ -z "${{ steps.resolve.outputs.ssh_known_hosts }}" ]; then
            echo "::error::require_ssh_known_hosts=true exige ssh_known_hosts"
            exit 1
          fi

          if [ -z "${{ secrets.WORKER_RUN_ENVS_FILE }}" ] && [ -z "${{ steps.resolve.outputs.worker_run_envs }}" ]; then
            echo "::warning::worker_run_envs vazio e WORKER_RUN_ENVS_FILE não configurado. Secrets não são injetados automaticamente; use WORKER_RUN_ENVS_FILE para variáveis sensíveis."
          fi

      - name: Publish pre-deploy summary
        if: always()
        run: |
          {
            echo "## pre-deploy-config summary"
            echo "- app: ${{ steps.resolve.outputs.app_name }}"
            echo "- environment: ${{ inputs.environment }}"
            echo "- ssh host configured: ${{ steps.resolve.outputs.ssh_host != '' && 'yes' || 'no' }}"
            echo "- worker name: ${{ steps.resolve.outputs.worker_name }}"
            echo "- registry auth required: ${{ steps.resolve.outputs.remote_docker_login }}"
          } >> "$GITHUB_STEP_SUMMARY"

  deploy:
    name: deploy
    if: ${{ always() && needs.build.result == 'success' && needs.security.result == 'success' && (needs.release.result == 'success' || needs.release.result == 'skipped') && github.event_name != 'pull_request' && (!inputs.deploy_on_tag_only || startsWith(github.ref, format('refs/tags/{0}', inputs.semver_prefix))) }}
    needs: [build, security, release]
    runs-on: ubuntu-latest
    timeout-minutes: 25
    environment: ${{ inputs.environment }}
    concurrency:
      group: worker-${{ inputs.app_name != '' && inputs.app_name || github.event.repository.name || github.repository }}-${{ inputs.environment }}
      cancel-in-progress: true
    permissions:
      contents: read
    steps:
      - name: Resolve deploy config (inputs + GitHub vars)
        id: resolve
        env:
          VARS_JSON: ${{ toJSON(vars) }}
          IN_APP_NAME: ${{ inputs.app_name != '' && inputs.app_name || github.event.repository.name || github.repository }}
          IN_SSH_USER: ${{ inputs.ssh_user }}
          IN_SSH_HOST: ${{ inputs.ssh_host }}
          IN_SSH_REMOTE_PORT: ${{ inputs.ssh_remote_port }}
          IN_SSH_KNOWN_HOSTS: ${{ inputs.ssh_known_hosts }}
          IN_REQUIRE_SSH_KNOWN_HOSTS: ${{ inputs.require_ssh_known_hosts }}
          IN_WORKER_NAME: ${{ inputs.worker_name }}
          IN_WORKER_RUN_ENVS: ${{ inputs.worker_run_envs }}
          IN_WORKER_EXTRA_ARGS: ${{ inputs.worker_extra_args }}
          IN_REMOTE_DOCKER_LOGIN: ${{ inputs.remote_docker_login }}
          IN_IMAGE_RETENTION_COUNT: ${{ inputs.image_retention_count }}
          IN_STARTUP_CHECK_RETRIES: ${{ inputs.startup_check_retries }}
          IN_STARTUP_CHECK_DELAY_SECONDS: ${{ inputs.startup_check_delay_seconds }}
          IN_PRUNE_RUNNER: ${{ inputs.prune_runner }}
          IN_INJECT_ALL_GITHUB_VARS: ${{ inputs.inject_all_github_vars }}
          IN_GITHUB_VARS_PREFIX: ${{ inputs.github_vars_prefix }}
          IN_GITHUB_VARS_EXCLUDE: ${{ inputs.github_vars_exclude }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const fs = require('fs');

          const vars = JSON.parse(process.env.VARS_JSON || '{}');

          const pickString = (...values) => {
            for (const v of values) {
              if (v === undefined || v === null) continue;
              const s = String(v).trim();
              if (s !== '') return s;
            }
            return '';
          };

          const pickPositiveInt = (fallback, ...values) => {
            for (const v of values) {
              if (v === undefined || v === null) continue;
              const s = String(v).trim();
              if (s === '' || s === '0') continue;
              const n = Number(s);
              if (Number.isFinite(n) && n > 0) return Math.floor(n);
            }
            return fallback;
          };

          const pickNonNegativeInt = (fallback, ...values) => {
            for (const v of values) {
              if (v === undefined || v === null) continue;
              const s = String(v).trim();
              if (s === '') continue;
              const n = Number(s);
              if (Number.isFinite(n) && n >= 0) return Math.floor(n);
            }
            return fallback;
          };

          const toBool = (v, fallback = false) => {
            if (v === undefined || v === null) return fallback;
            const s = String(v).trim().toLowerCase();
            if (s === '') return fallback;
            if (['1', 'true', 'yes', 'y', 'on'].includes(s)) return true;
            if (['0', 'false', 'no', 'n', 'off'].includes(s)) return false;
            return fallback;
          };

          const out = {
            app_name: pickString(process.env.IN_APP_NAME),
            ssh_user: pickString(process.env.IN_SSH_USER, vars.SSH_USER),
            ssh_host: pickString(process.env.IN_SSH_HOST, vars.SSH_HOST),
            ssh_remote_port: pickPositiveInt(22, process.env.IN_SSH_REMOTE_PORT, vars.SSH_REMOTE_PORT),
            ssh_known_hosts: pickString(process.env.IN_SSH_KNOWN_HOSTS, vars.SSH_KNOWN_HOSTS),
            require_ssh_known_hosts: toBool(process.env.IN_REQUIRE_SSH_KNOWN_HOSTS, false) || toBool(vars.REQUIRE_SSH_KNOWN_HOSTS, false),
            worker_name: pickString(process.env.IN_WORKER_NAME, vars.WORKER_NAME, process.env.IN_APP_NAME),
            worker_run_envs: pickString(process.env.IN_WORKER_RUN_ENVS, vars.WORKER_RUN_ENVS),
            worker_extra_args: pickString(process.env.IN_WORKER_EXTRA_ARGS, vars.WORKER_EXTRA_ARGS),
            remote_docker_login: toBool(process.env.IN_REMOTE_DOCKER_LOGIN, true),
            image_retention_count: pickPositiveInt(5, process.env.IN_IMAGE_RETENTION_COUNT, vars.IMAGE_RETENTION_COUNT),
            startup_check_retries: pickPositiveInt(6, process.env.IN_STARTUP_CHECK_RETRIES, vars.STARTUP_CHECK_RETRIES),
            startup_check_delay_seconds: pickNonNegativeInt(5, process.env.IN_STARTUP_CHECK_DELAY_SECONDS, vars.STARTUP_CHECK_DELAY_SECONDS),
            prune_runner: toBool(process.env.IN_PRUNE_RUNNER, true),
            inject_all_github_vars: toBool(process.env.IN_INJECT_ALL_GITHUB_VARS, true),
            github_vars_prefix: pickString(process.env.IN_GITHUB_VARS_PREFIX, vars.GITHUB_VARS_PREFIX),
            github_vars_exclude: pickString(process.env.IN_GITHUB_VARS_EXCLUDE, vars.GITHUB_VARS_EXCLUDE),
          };

          for (const [k, v] of Object.entries(out)) {
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `${k}=${String(v)}\n`);
          }
          NODE

      - name: Validate deploy config
        run: |
          set -euo pipefail
          [ -n "${{ steps.resolve.outputs.ssh_user }}" ] || { echo "::error::ssh_user ausente (input ou var SSH_USER)"; exit 1; }
          [ -n "${{ steps.resolve.outputs.ssh_host }}" ] || { echo "::error::ssh_host ausente (input ou var SSH_HOST)"; exit 1; }
          [ -n "${{ secrets.PEM_KEY }}" ] || { echo "::error::PEM_KEY ausente"; exit 1; }

          if [ "${{ steps.resolve.outputs.remote_docker_login }}" = "true" ] && { [ -z "${{ secrets.DEPLOY_REGISTRY_USERNAME }}" ] || [ -z "${{ secrets.DEPLOY_REGISTRY_PASSWORD }}" ]; }; then
            echo "::error::DEPLOY_REGISTRY_USERNAME/DEPLOY_REGISTRY_PASSWORD obrigatórios quando remote_docker_login=true"
            exit 1
          fi

          if [ "${{ steps.resolve.outputs.require_ssh_known_hosts }}" = "true" ] && [ -z "${{ steps.resolve.outputs.ssh_known_hosts }}" ]; then
            echo "::error::require_ssh_known_hosts=true exige ssh_known_hosts"
            exit 1
          fi

      - name: Configure known_hosts
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          if [ -n "${{ steps.resolve.outputs.ssh_known_hosts }}" ]; then
            printf '%s\n' "${{ steps.resolve.outputs.ssh_known_hosts }}" >> ~/.ssh/known_hosts
          fi

          if [ "${{ steps.resolve.outputs.require_ssh_known_hosts }}" != "true" ]; then
            ssh-keyscan -T 10 -H -p "${{ steps.resolve.outputs.ssh_remote_port }}" "${{ steps.resolve.outputs.ssh_host }}" >> ~/.ssh/known_hosts
          fi

          sort -u ~/.ssh/known_hosts -o ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Configure SSH key
        run: |
          set -euo pipefail
          printf '%s\n' "${{ secrets.PEM_KEY }}" > ./deploy-key.pem
          chmod 600 ./deploy-key.pem

      - name: Build env file from GitHub vars
        id: auto_vars
        env:
          VARS_JSON: ${{ toJSON(vars) }}
          INJECT_ALL: ${{ steps.resolve.outputs.inject_all_github_vars }}
          PREFIX: ${{ steps.resolve.outputs.github_vars_prefix }}
          EXCLUDE: ${{ steps.resolve.outputs.github_vars_exclude }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const fs = require('fs');

          const vars = JSON.parse(process.env.VARS_JSON || '{}');
          const includeAll = String(process.env.INJECT_ALL || '').toLowerCase() === 'true';
          const prefix = (process.env.PREFIX || '').trim();
          const rawExclude = (process.env.EXCLUDE || '').trim();
          const patterns = rawExclude
            ? rawExclude.split(/[\n,]/).map((s) => s.trim()).filter(Boolean)
            : [];

          const isValidEnvName = (k) => /^[A-Za-z_][A-Za-z0-9_]*$/.test(k);
          const matchPattern = (key, pattern) => {
            if (pattern.endsWith('*')) return key.startsWith(pattern.slice(0, -1));
            return key === pattern;
          };

          const excluded = (key) => patterns.some((p) => matchPattern(key, p));

          let lines = [];
          let skippedInvalid = 0;
          let skippedMultiline = 0;

          if (includeAll) {
            const keys = Object.keys(vars).sort();
            for (const key of keys) {
              if (prefix && !key.startsWith(prefix)) continue;
              if (excluded(key)) continue;
              if (!isValidEnvName(key)) {
                skippedInvalid += 1;
                continue;
              }
              const value = vars[key];
              if (value === undefined || value === null) continue;
              const str = String(value);
              if (/[\r\n\0]/.test(str)) {
                skippedMultiline += 1;
                continue;
              }
              lines.push(`${key}=${str}`);
            }
          }

          const path = `${process.env.RUNNER_TEMP}/worker-auto-vars.env`;
          fs.writeFileSync(path, lines.length ? `${lines.join('\n')}\n` : '');

          const b64 = lines.length ? Buffer.from(fs.readFileSync(path)).toString('base64') : '';

          fs.appendFileSync(process.env.GITHUB_OUTPUT, `auto_vars_count=${lines.length}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `skipped_invalid=${skippedInvalid}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `skipped_multiline=${skippedMultiline}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `auto_vars_b64=${b64}\n`);
          NODE

      - name: Deploy worker via SSH
        env:
          STAGE_IMAGE: ${{ needs.build.outputs.stage_image }}
          RELEASE_IMAGE: ${{ needs.release.outputs.release_image }}
          IS_TAG: ${{ startsWith(github.ref, format('refs/tags/{0}', inputs.semver_prefix)) }}
          IN_REGISTRY: ${{ inputs.registry }}
          IN_IMAGE_NAME: ${{ inputs.image_name }}
          IN_IMAGE_NAMESPACE: ${{ inputs.image_namespace }}
          IN_SEMVER_PREFIX: ${{ inputs.semver_prefix }}
          IN_WORKING_DIRECTORY: ${{ inputs.working_directory }}
          GIT_REF: ${{ github.ref }}
          GIT_SHA: ${{ github.sha }}
          GIT_REPOSITORY: ${{ github.repository }}
          SSH_USER: ${{ steps.resolve.outputs.ssh_user }}
          SSH_HOST: ${{ steps.resolve.outputs.ssh_host }}
          SSH_PORT: ${{ steps.resolve.outputs.ssh_remote_port }}
          WORKER_NAME: ${{ steps.resolve.outputs.worker_name }}
          WORKER_RUN_ENVS: ${{ steps.resolve.outputs.worker_run_envs }}
          WORKER_RUN_ENVS_FILE_SECRET: ${{ secrets.WORKER_RUN_ENVS_FILE }}
          AUTO_VARS_B64: ${{ steps.auto_vars.outputs.auto_vars_b64 }}
          WORKER_EXTRA_ARGS: ${{ steps.resolve.outputs.worker_extra_args }}
          STARTUP_CHECK_RETRIES: ${{ steps.resolve.outputs.startup_check_retries }}
          STARTUP_CHECK_DELAY: ${{ steps.resolve.outputs.startup_check_delay_seconds }}
          IMAGE_RETENTION_COUNT: ${{ steps.resolve.outputs.image_retention_count }}
          REMOTE_DOCKER_LOGIN: ${{ steps.resolve.outputs.remote_docker_login }}
          REGISTRY_USERNAME: ${{ secrets.DEPLOY_REGISTRY_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.DEPLOY_REGISTRY_PASSWORD }}
        run: |
          set -euo pipefail

          compute_images() {
            local ref="${GIT_REF}"
            local sha="${GIT_SHA}"
            local repo="${GIT_REPOSITORY}"
            local registry_input="${IN_REGISTRY}"
            local image_input="${IN_IMAGE_NAME}"
            local image_namespace="${IN_IMAGE_NAMESPACE}"
            local semver_prefix="${IN_SEMVER_PREFIX}"
            local working_directory="${IN_WORKING_DIRECTORY}"

            if [ -z "${registry_input}" ]; then
              registry_input="ghcr.io"
            fi
            local registry="${registry_input,,}"

            if [ -z "${image_input}" ]; then
              if [ "${registry}" = "ghcr.io" ]; then
                image_input="${repo}/worker"
              else
                image_input="${repo}"
              fi
            fi

            if [ -z "${registry}" ]; then
              echo "::error::registry vazio"
              exit 1
            fi
            if printf '%s' "${registry}" | grep -Eq '://|/|[[:space:]]'; then
              echo "::error::registry invalido: '${registry}'. Use apenas o host (ex.: ghcr.io, docker.io, registry.exemplo.com:5000), sem 'https://' e sem '/'."
              exit 1
            fi

            if printf '%s' "${image_input}" | grep -Eq '://|[[:space:]]'; then
              echo "::error::image_name invalido: '${image_input}'. Nao use URL e nao use espacos."
              exit 1
            fi
            if printf '%s' "${image_input}" | grep -Eq '[@:]'; then
              echo "::error::image_name nao deve conter tag/digest (':' ou '@'). Informe somente o repositorio (ex.: 'aviait/tei-worker' ou '${repo}/worker')."
              exit 1
            fi
            local first_segment="${image_input%%/*}"
            if [ "${first_segment}" != "${image_input}" ]; then
              if printf '%s' "${first_segment}" | grep -Eq '[\\.:]' || [ "${first_segment}" = "localhost" ]; then
                echo "::error::image_name nao deve incluir o registry host (ex.: 'ghcr.io/...'). Use o input registry para isso."
                exit 1
              fi
            fi

            if [ -n "${image_namespace}" ] && printf '%s' "${image_namespace}" | grep -Eq '[:/@]|[[:space:]]'; then
              echo "::error::image_namespace invalido: '${image_namespace}'. Use apenas o namespace (ex.: aviait), sem '/', ':', '@' e sem espacos."
              exit 1
            fi

            local image_path="${image_input}"
            if ! printf '%s' "${image_path}" | grep -q '/'; then
              if [ -n "${image_namespace}" ]; then
                image_path="${image_namespace}/${image_path}"
              else
                image_path="${repo%%/*}/${image_path}"
              fi
            fi

            if [ "${registry}" = "docker.io" ]; then
              local slash_count
              slash_count="$(printf '%s' "${image_path}" | awk -F/ '{print NF-1}')"
              if [ "${slash_count}" -ne 1 ]; then
                echo "::error::Para Docker Hub (docker.io), a imagem deve ser no formato 'namespace/repo'. Recebido: '${image_path}'."
                echo "::error::Sugestao: defina image_name como 'namespace/repo' (ex.: 'aviait/tei-worker') e opcionalmente use image_namespace."
                exit 1
              fi
            fi

            local image="${registry}/${image_path}"
            image="${image,,}"
            local sha_tag="sha-${sha::12}"
            COMPUTED_STAGE_IMAGE="${image}:${sha_tag}"
            COMPUTED_RELEASE_IMAGE=""

            if [[ "${ref}" == refs/tags/${semver_prefix}* ]]; then
              local git_tag="${ref#refs/tags/}"
              local pkg_json="${working_directory}/package.json"
              local pkg_version=""
              if [ -f "${pkg_json}" ]; then
                pkg_version="$(python3 -c "import json,sys; print(str(json.load(open(sys.argv[1], encoding='utf-8')).get('version','')).strip())" "${pkg_json}" 2>/dev/null || true)"
              fi

              local release_tag="${git_tag}"
              if [ -n "${pkg_version}" ]; then
                if [ "${git_tag}" != "${semver_prefix}${pkg_version}" ] && [ "${git_tag}" != "${pkg_version}" ]; then
                  echo "::error::Tag '${git_tag}' nao corresponde a versao do package.json ('${pkg_version}'). Esperado '${semver_prefix}${pkg_version}'."
                  exit 1
                fi
                release_tag="${pkg_version}"
              fi

              COMPUTED_RELEASE_IMAGE="${image}:${release_tag}"
            fi
          }

          if [ -z "${STAGE_IMAGE}" ] || { [ "${IS_TAG}" = "true" ] && [ -z "${RELEASE_IMAGE}" ]; }; then
            echo "::warning::Imagem nao resolvida via outputs (stage/release). Recomputando a partir de inputs + SHA."
            compute_images
            if [ -z "${STAGE_IMAGE}" ]; then
              STAGE_IMAGE="${COMPUTED_STAGE_IMAGE}"
            fi
            if [ -z "${RELEASE_IMAGE}" ] && [ -n "${COMPUTED_RELEASE_IMAGE}" ]; then
              RELEASE_IMAGE="${COMPUTED_RELEASE_IMAGE}"
            fi
          fi

          TARGET_IMAGE="${STAGE_IMAGE}"
          if [ "${IS_TAG}" = "true" ] && [ -n "${RELEASE_IMAGE}" ]; then
            TARGET_IMAGE="${RELEASE_IMAGE}"
          fi

          if [ -z "${TARGET_IMAGE}" ]; then
            echo "::error::TARGET_IMAGE vazio (verifique build/release outputs e inputs de imagem)"
            exit 1
          fi
          if printf '%s' "${TARGET_IMAGE}" | grep -Eq '://|[[:space:]]'; then
            echo "::error::TARGET_IMAGE invalida: '${TARGET_IMAGE}'"
            exit 1
          fi
          echo "TARGET_IMAGE=${TARGET_IMAGE}"

          WORKER_RUN_ENVS_B64="$(printf '%s' "${WORKER_RUN_ENVS}" | base64 | tr -d '\n')"

          TMP_ENV_FILE="$(mktemp)"
          trap 'rm -f "${TMP_ENV_FILE}"' EXIT

          if [ -n "${WORKER_RUN_ENVS_FILE_SECRET}" ]; then
            printf '%s\n' "${WORKER_RUN_ENVS_FILE_SECRET}" >> "${TMP_ENV_FILE}"
          fi

          if [ -n "${AUTO_VARS_B64}" ]; then
            printf '%s' "${AUTO_VARS_B64}" | base64 -d >> "${TMP_ENV_FILE}"
          fi

          WORKER_RUN_ENVS_FILE_B64=""
          if [ -s "${TMP_ENV_FILE}" ]; then
            WORKER_RUN_ENVS_FILE_B64="$(base64 -w0 "${TMP_ENV_FILE}")"
          fi

          REPOSITORY="${TARGET_IMAGE%:*}"
          REGISTRY="${TARGET_IMAGE%%/*}"
          echo "REGISTRY=${REGISTRY}"
          echo "REPOSITORY=${REPOSITORY}"

          ssh -o StrictHostKeyChecking=yes -o UserKnownHostsFile=~/.ssh/known_hosts -o ConnectTimeout=10 -p "${SSH_PORT}" -i ./deploy-key.pem \
            "${SSH_USER}@${SSH_HOST}" \
            env \
            IMAGE_REF="${TARGET_IMAGE}" \
            REPOSITORY="${REPOSITORY}" \
            REGISTRY="${REGISTRY}" \
            REGISTRY_USERNAME="${REGISTRY_USERNAME}" \
            REGISTRY_PASSWORD="${REGISTRY_PASSWORD}" \
            REMOTE_DOCKER_LOGIN="${REMOTE_DOCKER_LOGIN}" \
            WORKER_NAME="${WORKER_NAME}" \
            WORKER_RUN_ENVS_B64="${WORKER_RUN_ENVS_B64}" \
            WORKER_RUN_ENVS_FILE_B64="${WORKER_RUN_ENVS_FILE_B64}" \
            WORKER_EXTRA_ARGS="${WORKER_EXTRA_ARGS}" \
            STARTUP_CHECK_RETRIES="${STARTUP_CHECK_RETRIES}" \
            STARTUP_CHECK_DELAY="${STARTUP_CHECK_DELAY}" \
            IMAGE_RETENTION_COUNT="${IMAGE_RETENTION_COUNT}" \
            bash -s << 'EOF'
            set -euo pipefail

            if [ -z "${IMAGE_REF}" ]; then
              echo "IMAGE_REF vazio"
              exit 1
            fi
            if printf '%s' "${IMAGE_REF}" | grep -Eq '://|[[:space:]]'; then
              echo "IMAGE_REF invalida: '${IMAGE_REF}'"
              exit 1
            fi
            echo "IMAGE_REF=${IMAGE_REF}"
            echo "REGISTRY=${REGISTRY}"
            echo "WORKER_NAME=${WORKER_NAME}"

            WORKER_RUN_ENVS="$(printf '%s' "${WORKER_RUN_ENVS_B64}" | base64 -d || true)"
            TMP_ENV_FILE=""
            DOCKER_RUN_ARGS=(-d --restart unless-stopped --name "${WORKER_NAME}")
            WORKER_EXTRA_ARGS_ARRAY=()

            cleanup_tmp_env_file() {
              if [ -n "${TMP_ENV_FILE}" ] && [ -f "${TMP_ENV_FILE}" ]; then
                rm -f "${TMP_ENV_FILE}"
              fi
            }
            trap cleanup_tmp_env_file EXIT

            if [ -n "${WORKER_RUN_ENVS_FILE_B64}" ]; then
              TMP_ENV_FILE="$(mktemp)"
              printf '%s' "${WORKER_RUN_ENVS_FILE_B64}" | base64 -d > "${TMP_ENV_FILE}"
              DOCKER_RUN_ARGS+=(--env-file "${TMP_ENV_FILE}")
            fi

            if [ -n "${WORKER_RUN_ENVS}" ]; then
              # Format supported:
              # - One per line: KEY=VALUE (recommended)
              # - Backward compatible: "-e KEY=VALUE" or "--env KEY=VALUE"
              while IFS= read -r line; do
                line="$(printf '%s' "${line}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
                [ -z "${line}" ] && continue
                case "${line}" in
                  \#*) continue ;;
                esac

                if printf '%s' "${line}" | grep -Eq '^(--env|-e)[[:space:]]+'; then
                  flag="${line%% *}"
                  val="${line#* }"
                  DOCKER_RUN_ARGS+=("${flag}" "${val}")
                else
                  DOCKER_RUN_ARGS+=(--env "${line}")
                fi
              done <<< "${WORKER_RUN_ENVS}"
            fi

            if [ -n "${WORKER_EXTRA_ARGS}" ]; then
              read -r -a WORKER_EXTRA_ARGS_ARRAY <<< "${WORKER_EXTRA_ARGS}"
            fi

            PREVIOUS_IMAGE_ID="$(docker inspect -f '{{.Image}}' "${WORKER_NAME}" 2>/dev/null || true)"

            if [ "${REMOTE_DOCKER_LOGIN}" = "true" ]; then
              echo "${REGISTRY_PASSWORD}" | docker login "${REGISTRY}" -u "${REGISTRY_USERNAME}" --password-stdin
            fi

            docker pull "${IMAGE_REF}"

            docker stop "${WORKER_NAME}" || true
            docker rm "${WORKER_NAME}" || true

            if ! docker run "${DOCKER_RUN_ARGS[@]}" "${IMAGE_REF}" "${WORKER_EXTRA_ARGS_ARRAY[@]}"; then
              docker logs --tail 200 "${WORKER_NAME}" 2>/dev/null || true
              if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                docker run "${DOCKER_RUN_ARGS[@]}" "${PREVIOUS_IMAGE_ID}" "${WORKER_EXTRA_ARGS_ARRAY[@]}" || true
              fi
              exit 1
            fi

            attempt=1
            while [ "${attempt}" -le "${STARTUP_CHECK_RETRIES}" ]; do
              if docker ps --filter "name=${WORKER_NAME}" --filter "status=running" --format '{{.ID}}' | grep -q .; then
                break
              fi
              if [ "${attempt}" -eq "${STARTUP_CHECK_RETRIES}" ]; then
                docker ps -a --filter "name=${WORKER_NAME}" || true
                docker logs --tail 200 "${WORKER_NAME}" 2>/dev/null || true
                docker stop "${WORKER_NAME}" || true
                docker rm "${WORKER_NAME}" || true
                if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                  docker run "${DOCKER_RUN_ARGS[@]}" "${PREVIOUS_IMAGE_ID}" "${WORKER_EXTRA_ARGS_ARRAY[@]}" || true
                fi
                exit 1
              fi
              attempt=$((attempt+1))
              sleep "${STARTUP_CHECK_DELAY}"
            done

            OLD_IMAGE_IDS="$(docker image ls "${REPOSITORY}" --format '{{.CreatedAt}} {{.ID}}' | sort -r | awk "NR>${IMAGE_RETENTION_COUNT}{print \$2}")"
            if [ -n "${OLD_IMAGE_IDS}" ]; then
              echo "${OLD_IMAGE_IDS}" | xargs -r docker image rm -f || true
            fi
            docker image prune -f >/dev/null 2>&1 || true
          EOF

      - name: Remove SSH key
        if: always()
        run: rm -f ./deploy-key.pem

      - name: Prune runner
        if: ${{ always() && steps.resolve.outputs.prune_runner == 'true' }}
        run: docker system prune -af --volumes || true

      - name: Publish deploy summary
        if: always()
        run: |
          {
            echo "## deploy summary"
            echo "- app: ${{ steps.resolve.outputs.app_name }}"
            echo "- environment: ${{ inputs.environment }}"
            echo "- ref: \`${{ github.ref }}\`"
            echo "- worker_run_envs provided: ${{ steps.resolve.outputs.worker_run_envs != '' && 'yes' || 'no' }}"
            echo "- worker_run_envs_file secret provided: ${{ secrets.WORKER_RUN_ENVS_FILE != '' && 'yes' || 'no' }}"
            echo "- startup_check: retries=${{ steps.resolve.outputs.startup_check_retries }}, delay=${{ steps.resolve.outputs.startup_check_delay_seconds }}s"
            echo "- auto vars injected: ${{ steps.auto_vars.outputs.auto_vars_count }}"
            echo "- auto vars skipped (invalid name): ${{ steps.auto_vars.outputs.skipped_invalid }}"
            echo "- auto vars skipped (multiline/null): ${{ steps.auto_vars.outputs.skipped_multiline }}"
          } >> "$GITHUB_STEP_SUMMARY"

  summary:
    name: summary
    if: ${{ always() }}
    needs:
      - quality
      - build
      - security
      - release
      - pre_deploy_config
      - deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Publish pipeline summary
        run: |
          {
            echo "## v2-worker summary"
            echo ""
            echo "- ref: \`${{ github.ref }}\`"
            echo "- event: \`${{ github.event_name }}\`"
            echo "- environment: \`${{ inputs.environment }}\`"
            echo ""
            echo "| Job | Result |"
            echo "|---|---|"
            echo "| quality | ${{ needs.quality.result }} |"
            echo "| build | ${{ needs.build.result }} |"
            echo "| security | ${{ needs.security.result }} |"
            echo "| release | ${{ needs.release.result }} |"
            echo "| pre-deploy-config | ${{ needs.pre_deploy_config.result }} |"
            echo "| deploy | ${{ needs.deploy.result }} |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Publish execution path
        env:
          QUALITY_RESULT: ${{ needs.quality.result }}
          BUILD_RESULT: ${{ needs.build.result }}
          SECURITY_RESULT: ${{ needs.security.result }}
          RELEASE_RESULT: ${{ needs.release.result }}
          PRE_DEPLOY_RESULT: ${{ needs.pre_deploy_config.result }}
          DEPLOY_RESULT: ${{ needs.deploy.result }}
        run: |
          set -euo pipefail

          flow_part() {
            local label="$1"
            local result="$2"
            if [ "${result}" = "success" ]; then
              printf "%s" "${label}"
            elif [ "${result}" = "skipped" ]; then
              printf "(%s skipped)" "${label}"
            else
              printf "%s[%s]" "${label}" "${result}"
            fi
          }

          FLOW="$(flow_part "quality" "${QUALITY_RESULT}")"
          FLOW="${FLOW} -> $(flow_part "build" "${BUILD_RESULT}")"
          FLOW="${FLOW} -> $(flow_part "security" "${SECURITY_RESULT}")"
          FLOW="${FLOW} -> $(flow_part "release" "${RELEASE_RESULT}")"
          FLOW="${FLOW} -> $(flow_part "pre-deploy-config" "${PRE_DEPLOY_RESULT}")"
          FLOW="${FLOW} -> $(flow_part "deploy" "${DEPLOY_RESULT}")"

          OVERALL="success"
          for result in "${QUALITY_RESULT}" "${BUILD_RESULT}" "${SECURITY_RESULT}" "${RELEASE_RESULT}" "${PRE_DEPLOY_RESULT}" "${DEPLOY_RESULT}"; do
            if [ "${result}" = "failure" ] || [ "${result}" = "cancelled" ]; then
              OVERALL="failed"
              break
            fi
          done

          {
            echo ""
            echo "### execution path"
            echo "- overall: \`${OVERALL}\`"
            echo "- path: \`${FLOW}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Enforce CI gates
        if: ${{ needs.quality.result == 'failure' || needs.quality.result == 'cancelled' || needs.build.result == 'failure' || needs.build.result == 'cancelled' || needs.security.result == 'failure' || needs.security.result == 'cancelled' || needs.pre_deploy_config.result == 'failure' || needs.pre_deploy_config.result == 'cancelled' }}
        run: |
          echo "::error::Falha nos gates obrigatórios (quality/build/security/pre-deploy-config)."
          exit 1
