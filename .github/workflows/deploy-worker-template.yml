name: Deploy Worker Project Template

on:
  workflow_call:
    inputs:
      ENVIRONMENT:
        required: true
        type: string
      PROJECT_NAME:
        required: true
        type: string
      NODE_VERSION:
        required: false
        type: string
        default: "20"
      VERSION_CMD:
        required: false
        type: string
        default: "node -p \"require('./package.json').version\""
      PACKAGE_MANAGER:
        required: false
        type: string
        default: "yarn"
      INSTALL_CMD:
        required: false
        type: string
        default: "yarn install --immutable"
      BUILD_CMD:
        required: false
        type: string
        default: "yarn build"
      CACHE_DEPENDENCY_PATH:
        required: false
        type: string
        default: ""
      SSH_USER:
        required: true
        type: string
      SSH_HOST:
        required: true
        type: string
      SSH_KNOWN_HOSTS:
        required: false
        type: string
        default: ""
      REQUIRE_SSH_KNOWN_HOSTS:
        required: false
        type: boolean
        default: false
      WORKER_NAME:
        required: true
        type: string
      DOCKER_IMAGE:
        required: true
        type: string
      DOCKER_USERNAME:
        required: false
        type: string
        default: ""
      DOCKER_PASSWORD:
        required: false
        type: string
        default: ""
      WORKER_RUN_ENVS:
        required: false
        type: string
        default: ""
      WORKER_RUN_ENVS_FILE:
        required: false
        type: string
        default: ""
      WORKER_EXTRA_ARGS:
        required: false
        type: string
        default: ""
      DOCKER_PLATFORM:
        required: false
        type: string
        default: linux/amd64
      DOCKER_BUILD_ARGS:
        required: false
        type: string
        default: ""
      REGISTRY:
        required: false
        type: string
        default: docker.io
      IMAGE_NAMESPACE:
        required: false
        type: string
        default: ""
      IMAGE_RETENTION_COUNT:
        required: false
        type: number
        default: 5
      SSH_REMOTE_PORT:
        required: false
        type: number
        default: 22
      REMOTE_DOCKER_LOGIN:
        required: false
        type: boolean
        default: true
      STARTUP_CHECK_RETRIES:
        required: false
        type: number
        default: 6
      STARTUP_CHECK_DELAY:
        required: false
        type: number
        default: 5
      PRUNE_RUNNER:
        required: false
        type: boolean
        default: true
    secrets:
      PEM_KEY:
        required: true
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true

jobs:
  deploy:
    name: üöÄ Deploy Worker ${{ inputs.WORKER_NAME }} (${{ inputs.ENVIRONMENT }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    concurrency:
      group: deploy-worker-${{ inputs.PROJECT_NAME }}-${{ inputs.WORKER_NAME }}-${{ inputs.ENVIRONMENT }}
      cancel-in-progress: true
    permissions:
      contents: read
    environment: ${{ inputs.ENVIRONMENT }}
    defaults:
      run:
        shell: bash
    outputs:
      version: ${{ steps.version.outputs.version }}
      image_ref: ${{ steps.image_metadata.outputs.image_ref }}
    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      REGISTRY: ${{ inputs.REGISTRY != '' && inputs.REGISTRY || 'docker.io' }}
      IMAGE_NAMESPACE: ${{ inputs.IMAGE_NAMESPACE != '' && inputs.IMAGE_NAMESPACE || secrets.DOCKER_USERNAME }}

    steps:
      - name: üõí Checkout c√≥digo
        uses: actions/checkout@v6

      - name: üß∞ Configurar Node (cache customizado)
        if: ${{ inputs.CACHE_DEPENDENCY_PATH != '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ inputs.NODE_VERSION }}
          cache: ${{ inputs.PACKAGE_MANAGER }}
          cache-dependency-path: ${{ inputs.CACHE_DEPENDENCY_PATH }}

      - name: üß∞ Configurar Node
        if: ${{ inputs.CACHE_DEPENDENCY_PATH == '' }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ inputs.NODE_VERSION }}
          cache: ${{ inputs.PACKAGE_MANAGER }}

      - name: ‚úÖ Validar inputs e credenciais
        run: |
          if ! [[ "${{ inputs.PACKAGE_MANAGER }}" =~ ^(npm|yarn|pnpm)$ ]]; then
            echo "::error::PACKAGE_MANAGER deve ser um destes valores: npm, yarn, pnpm."
            exit 1
          fi

          if [ -z "${{ inputs.VERSION_CMD }}" ]; then
            echo "::error::VERSION_CMD n√£o pode ser vazio."
            exit 1
          fi

          if [ -n "${{ inputs.DOCKER_USERNAME }}" ] || [ -n "${{ inputs.DOCKER_PASSWORD }}" ]; then
            echo "::warning::Inputs DOCKER_USERNAME/DOCKER_PASSWORD est√£o deprecated. Use secrets."
          fi

          if [ -z "${{ inputs.INSTALL_CMD }}" ] || [ -z "${{ inputs.BUILD_CMD }}" ]; then
            echo "::error::INSTALL_CMD e BUILD_CMD n√£o podem ser vazios."
            exit 1
          fi

          if [ -z "${DOCKER_USERNAME}" ] || [ -z "${DOCKER_PASSWORD}" ]; then
            echo "::error::Secrets DOCKER_USERNAME/DOCKER_PASSWORD s√£o obrigat√≥rios."
            exit 1
          fi

          if [ -z "${IMAGE_NAMESPACE}" ]; then
            echo "::error::IMAGE_NAMESPACE ficou vazio. Informe IMAGE_NAMESPACE ou defina secret DOCKER_USERNAME."
            exit 1
          fi

          if ! [[ "${{ inputs.IMAGE_RETENTION_COUNT }}" =~ ^[1-9][0-9]*$ ]]; then
            echo "::error::IMAGE_RETENTION_COUNT deve ser um n√∫mero inteiro maior que zero."
            exit 1
          fi

          if ! [[ "${{ inputs.STARTUP_CHECK_RETRIES }}" =~ ^[1-9][0-9]*$ ]]; then
            echo "::error::STARTUP_CHECK_RETRIES deve ser um n√∫mero inteiro maior que zero."
            exit 1
          fi

          if ! [[ "${{ inputs.STARTUP_CHECK_DELAY }}" =~ ^[0-9]+$ ]]; then
            echo "::error::STARTUP_CHECK_DELAY deve ser um n√∫mero inteiro maior ou igual a zero."
            exit 1
          fi

          if [ "${{ inputs.REQUIRE_SSH_KNOWN_HOSTS }}" = "true" ] && [ -z "${{ inputs.SSH_KNOWN_HOSTS }}" ]; then
            echo "::error::REQUIRE_SSH_KNOWN_HOSTS=true exige SSH_KNOWN_HOSTS preenchido."
            exit 1
          fi

      - name: üõ†Ô∏è Instalar depend√™ncias do projeto
        run: ${{ inputs.INSTALL_CMD }}

      - name: üèóÔ∏è Buildar o projeto
        run: ${{ inputs.BUILD_CMD }}

      - name: üîê Registrar host SSH em known_hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          if [ -n "${{ inputs.SSH_KNOWN_HOSTS }}" ]; then
            printf '%s\n' "${{ inputs.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
          fi

          if [ "${{ inputs.REQUIRE_SSH_KNOWN_HOSTS }}" != "true" ]; then
            ssh-keyscan -H -p ${{ inputs.SSH_REMOTE_PORT }} ${{ inputs.SSH_HOST }} >> ~/.ssh/known_hosts
          fi

          sort -u ~/.ssh/known_hosts -o ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: üîë Configurar chave SSH privada
        run: |
          echo "${{ secrets.PEM_KEY }}" > ./deploy-key.pem
          chmod 600 ./deploy-key.pem

      - name: üî¢ Pegar vers√£o do projeto
        id: version
        run: |
          VERSION_CMD=$(cat << 'CMD'
          ${{ inputs.VERSION_CMD }}
          CMD
          )
          VERSION=$(bash -lc "${VERSION_CMD}")
          if [ -z "${VERSION}" ]; then
            echo "::error::VERSION_CMD retornou valor vazio."
            exit 1
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: ü™™ Registrar metadados da imagem
        id: image_metadata
        run: |
          IMAGE_REF="${REGISTRY}/${IMAGE_NAMESPACE}/${{ inputs.DOCKER_IMAGE }}:${VERSION}"
          echo "IMAGE_REF=${IMAGE_REF}" >> $GITHUB_ENV
          echo "image_ref=${IMAGE_REF}" >> $GITHUB_OUTPUT

      - name: üèóÔ∏è Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üê≥ Login no Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: üê≥ Build e Push da imagem do worker
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ inputs.DOCKER_IMAGE }}:${{ env.VERSION }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ inputs.DOCKER_IMAGE }}:latest
          platforms: ${{ inputs.DOCKER_PLATFORM }}
          build-args: ${{ inputs.DOCKER_BUILD_ARGS }}
          cache-from: type=gha,scope=${{ inputs.DOCKER_IMAGE }}-worker
          cache-to: type=gha,mode=max,scope=${{ inputs.DOCKER_IMAGE }}-worker
          provenance: true
          sbom: true
          labels: |
            org.opencontainers.image.title=${{ inputs.PROJECT_NAME }}-worker
            org.opencontainers.image.version=${{ env.VERSION }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp || github.run_id }}

      - name: üöÄ Atualizar worker no servidor
        run: |
          IMAGE_REF="${REGISTRY}/${IMAGE_NAMESPACE}/${{ inputs.DOCKER_IMAGE }}:${{ env.VERSION }}"
          REPOSITORY="${REGISTRY}/${IMAGE_NAMESPACE}/${{ inputs.DOCKER_IMAGE }}"
          KEEP_IMAGES=${{ inputs.IMAGE_RETENTION_COUNT }}
          REMOTE_DOCKER_LOGIN="${{ inputs.REMOTE_DOCKER_LOGIN }}"
          WORKER_ENV_MODE="inline"
          WORKER_RUN_ENVS_B64=$(printf '%s' "${{ inputs.WORKER_RUN_ENVS }}" | base64 | tr -d '\n')
          WORKER_RUN_ENVS_FILE_B64=""
          STARTUP_CHECK_RETRIES=${{ inputs.STARTUP_CHECK_RETRIES }}
          STARTUP_CHECK_DELAY=${{ inputs.STARTUP_CHECK_DELAY }}
          WORKER_EXTRA_ARGS="${{ inputs.WORKER_EXTRA_ARGS }}"

          if [ -n "${{ inputs.WORKER_RUN_ENVS_FILE }}" ]; then
            WORKER_ENV_MODE="file"
            WORKER_RUN_ENVS_FILE_B64=$(printf '%s\n' "${{ inputs.WORKER_RUN_ENVS_FILE }}" | base64 | tr -d '\n')
          fi

          ssh -o StrictHostKeyChecking=yes -o UserKnownHostsFile=~/.ssh/known_hosts -p ${{ inputs.SSH_REMOTE_PORT }} -i ./deploy-key.pem \
            ${{ inputs.SSH_USER }}@${{ inputs.SSH_HOST }} \
            env \
            DOCKER_USERNAME="${DOCKER_USERNAME}" \
            DOCKER_PASSWORD="${DOCKER_PASSWORD}" \
            REGISTRY="${REGISTRY}" \
            IMAGE_REF="${IMAGE_REF}" \
            REPOSITORY="${REPOSITORY}" \
            KEEP_IMAGES="${KEEP_IMAGES}" \
            WORKER_NAME="${{ inputs.WORKER_NAME }}" \
            WORKER_ENV_MODE="${WORKER_ENV_MODE}" \
            WORKER_RUN_ENVS_B64="${WORKER_RUN_ENVS_B64}" \
            WORKER_RUN_ENVS_FILE_B64="${WORKER_RUN_ENVS_FILE_B64}" \
            REMOTE_DOCKER_LOGIN="${REMOTE_DOCKER_LOGIN}" \
            STARTUP_CHECK_RETRIES="${STARTUP_CHECK_RETRIES}" \
            STARTUP_CHECK_DELAY="${STARTUP_CHECK_DELAY}" \
            WORKER_EXTRA_ARGS="${WORKER_EXTRA_ARGS}" \
            bash -s << 'EOF'
            set -euo pipefail

            WORKER_RUN_ENVS=$(printf '%s' "${WORKER_RUN_ENVS_B64}" | base64 -d)
            TMP_ENV_FILE=""
            DOCKER_RUN_ARGS=(-d --restart unless-stopped --name "${WORKER_NAME}")
            WORKER_RUN_ENVS_ARRAY=()
            WORKER_EXTRA_ARGS_ARRAY=()

            cleanup_tmp_env_file() {
              if [ -n "${TMP_ENV_FILE}" ] && [ -f "${TMP_ENV_FILE}" ]; then
                rm -f "${TMP_ENV_FILE}"
              fi
            }
            trap cleanup_tmp_env_file EXIT

            if [ "${WORKER_ENV_MODE}" = "file" ]; then
              TMP_ENV_FILE=$(mktemp)
              printf '%s' "${WORKER_RUN_ENVS_FILE_B64}" | base64 -d > "${TMP_ENV_FILE}"
              DOCKER_RUN_ARGS+=(--env-file "${TMP_ENV_FILE}")
            fi

            if [ -n "${WORKER_RUN_ENVS}" ]; then
              read -r -a WORKER_RUN_ENVS_ARRAY <<< "${WORKER_RUN_ENVS}"
              DOCKER_RUN_ARGS+=("${WORKER_RUN_ENVS_ARRAY[@]}")
            fi

            if [ -n "${WORKER_EXTRA_ARGS}" ]; then
              read -r -a WORKER_EXTRA_ARGS_ARRAY <<< "${WORKER_EXTRA_ARGS}"
            fi

            PREVIOUS_IMAGE_ID=$(docker inspect -f '{{.Image}}' "${WORKER_NAME}" 2>/dev/null || true)

            if [ "${REMOTE_DOCKER_LOGIN}" = "true" ]; then
              echo "${DOCKER_PASSWORD}" | docker login "${REGISTRY}" -u "${DOCKER_USERNAME}" --password-stdin
            fi

            docker pull "${IMAGE_REF}"

            docker stop "${WORKER_NAME}" || true
            docker rm "${WORKER_NAME}" || true

            if ! docker run "${DOCKER_RUN_ARGS[@]}" "${IMAGE_REF}" "${WORKER_EXTRA_ARGS_ARRAY[@]}"; then
              echo "Falha ao subir nova vers√£o do worker; tentando rollback..."
              if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                docker run "${DOCKER_RUN_ARGS[@]}" "${PREVIOUS_IMAGE_ID}" "${WORKER_EXTRA_ARGS_ARRAY[@]}" || true
              fi
              exit 1
            fi

            attempt=1
            while [ "${attempt}" -le "${STARTUP_CHECK_RETRIES}" ]; do
              if docker ps --filter "name=${WORKER_NAME}" --filter "status=running" --format '{{.ID}}' | grep -q .; then
                break
              fi
              if [ "${attempt}" -eq "${STARTUP_CHECK_RETRIES}" ]; then
                echo "Worker n√£o ficou em execu√ß√£o ap√≥s o deploy; rollback."
                docker stop "${WORKER_NAME}" || true
                docker rm "${WORKER_NAME}" || true
                if [ -n "${PREVIOUS_IMAGE_ID}" ]; then
                  docker run "${DOCKER_RUN_ARGS[@]}" "${PREVIOUS_IMAGE_ID}" "${WORKER_EXTRA_ARGS_ARRAY[@]}" || true
                fi
                exit 1
              fi
              echo "Worker ainda n√£o est√° running (tentativa ${attempt}/${STARTUP_CHECK_RETRIES}); aguardando ${STARTUP_CHECK_DELAY}s"
              attempt=$((attempt+1))
              sleep "${STARTUP_CHECK_DELAY}"
            done

            OLD_IMAGE_IDS=$(docker image ls "${REPOSITORY}" --format '{{.CreatedAt}} {{.ID}}' | sort -r | awk "NR>${KEEP_IMAGES}{print \$2}")
            if [ -n "${OLD_IMAGE_IDS}" ]; then
              echo "${OLD_IMAGE_IDS}" | xargs -r docker image rm -f || true
            fi
            docker image prune -f >/dev/null 2>&1 || true
          EOF

      - name: üßπ Apagar chave privada ap√≥s deploy
        if: always()
        run: rm -f ./deploy-key.pem

      - name: üßπ Limpar imagens locais do runner
        if: ${{ always() && inputs.PRUNE_RUNNER }}
        run: docker system prune -af --volumes || true

      - name: üìù Resumo do deploy
        if: always()
        run: |
          {
            echo "## Deploy Worker"
            echo "- Projeto: ${{ inputs.PROJECT_NAME }}"
            echo "- Ambiente: ${{ inputs.ENVIRONMENT }}"
            echo "- Worker: ${{ inputs.WORKER_NAME }}"
            echo "- Imagem: ${REGISTRY}/${IMAGE_NAMESPACE}/${{ inputs.DOCKER_IMAGE }}:${{ env.VERSION }}"
            echo "- Plataforma: ${{ inputs.DOCKER_PLATFORM }}"
            echo "- Imagens retidas: ${{ inputs.IMAGE_RETENTION_COUNT }}"
          } >> $GITHUB_STEP_SUMMARY
