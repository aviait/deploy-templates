name: auto-tag-production

on:
  workflow_run:
    workflows:
      - bff-v2-production
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write
  actions: write

concurrency:
  group: auto-tag-production-${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch || github.ref }}
  cancel-in-progress: true

jobs:
  tag:
    name: create tag from package.json
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'push' && github.event.workflow_run.head_branch == 'production') }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout (with tags)
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Resolve version
        id: ver
        env:
          PACKAGE_JSON_PATH: ${{ vars.RELEASE_PACKAGE_JSON_PATH != '' && vars.RELEASE_PACKAGE_JSON_PATH || 'package.json' }}
          SEMVER_PREFIX: ${{ vars.PIPELINE_SEMVER_PREFIX != '' && vars.PIPELINE_SEMVER_PREFIX || 'v' }}
        run: |
          set -euo pipefail

          if [ ! -f "${PACKAGE_JSON_PATH}" ]; then
            echo "::error::Arquivo nao encontrado: ${PACKAGE_JSON_PATH}"
            exit 1
          fi

          VERSION="$(python3 -c "import json,sys; print(str(json.load(open(sys.argv[1], encoding='utf-8')).get('version','')).strip())" "${PACKAGE_JSON_PATH}")"
          if [ -z "${VERSION}" ]; then
            echo "::error::package.json version vazio em ${PACKAGE_JSON_PATH}"
            exit 1
          fi

          TAG="${SEMVER_PREFIX}${VERSION}"

          # Basic sanity check; adjust if you allow prereleases/build metadata.
          if ! echo "${TAG}" | grep -Eq "^${SEMVER_PREFIX}[0-9]+\\.[0-9]+\\.[0-9]+([.-][0-9A-Za-z.-]+)?$"; then
            echo "::warning::Tag '${TAG}' nao parece semver padrao (vX.Y.Z)."
          fi

          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"

      - name: Resolve target production workflow file
        id: wf
        env:
          WORKFLOW_RUN_PATH: ${{ github.event.workflow_run.path }}
          WORKFLOW_FILE_VAR: ${{ vars.AUTO_TAG_TARGET_WORKFLOW_FILE }}
        run: |
          set -euo pipefail

          WORKFLOW_FILE="${WORKFLOW_FILE_VAR}"

          if [ -z "${WORKFLOW_FILE}" ] && [ -n "${WORKFLOW_RUN_PATH}" ]; then
            WORKFLOW_FILE="$(basename "${WORKFLOW_RUN_PATH}")"
          fi

          if [ -z "${WORKFLOW_FILE}" ]; then
            WORKFLOW_FILE="bff-production.yml"
          fi

          echo "workflow_file=${WORKFLOW_FILE}" >> "$GITHUB_OUTPUT"

      - name: Create and push tag (idempotent)
        id: push_tag
        env:
          GIT_TOKEN: ${{ secrets.GIT_TOKEN }}
          TAG: ${{ steps.ver.outputs.tag }}
        run: |
          set -euo pipefail
          echo "tag_pushed=false" >> "$GITHUB_OUTPUT"
          echo "tag_ready=false" >> "$GITHUB_OUTPUT"

          if [ -z "${GIT_TOKEN:-}" ]; then
            echo "::error::GIT_TOKEN ausente. Configure um PAT em secrets.GIT_TOKEN para que o push da tag dispare os workflows de release/deploy."
            exit 1
          fi

          git fetch --tags --force

          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            TAG_SHA="$(git rev-list -n 1 "${TAG}")"
            if [ "${TAG_SHA}" = "${GITHUB_SHA}" ]; then
              echo "::notice::Tag ${TAG} ja existe neste commit. Garantindo run de producao para a tag."
              echo "tag_ready=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            echo "::error::Tag ${TAG} ja existe apontando para outro commit (${TAG_SHA}). Bumpe a versao do package.json."
            exit 1
          fi

          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          git tag -a "${TAG}" -m "${TAG}"
          git remote set-url origin "https://x-access-token:${GIT_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git push origin "${TAG}"
          echo "tag_pushed=true" >> "$GITHUB_OUTPUT"
          echo "tag_ready=true" >> "$GITHUB_OUTPUT"

      - name: Ensure production workflow starts for tag
        if: ${{ steps.push_tag.outputs.tag_ready == 'true' }}
        env:
          API_TOKEN: ${{ secrets.GIT_TOKEN }}
          TAG: ${{ steps.ver.outputs.tag }}
          TARGET_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}
          WORKFLOW_FILE: ${{ steps.wf.outputs.workflow_file }}
        run: |
          set -euo pipefail

          if [ -z "${API_TOKEN:-}" ]; then
            echo "::error::GIT_TOKEN ausente para validar/disparar workflow de producao."
            exit 1
          fi

          RUNS_API="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/workflows/${WORKFLOW_FILE}/runs?per_page=50"
          find_run_url() {
            local runs_json="$1"
            printf '%s' "${runs_json}" | python3 - "${TAG}" "${TARGET_SHA}" <<'PY'
          import json
          import sys

          tag = sys.argv[1]
          target_sha = sys.argv[2]
          data = json.load(sys.stdin)

          for run in data.get("workflow_runs", []):
            if run.get("head_sha") != target_sha:
              continue
            ref = str(run.get("ref", ""))
            head_branch = str(run.get("head_branch", ""))
            event = str(run.get("event", ""))
            if (ref == f"refs/tags/{tag}" or head_branch == tag) and event in {"push", "workflow_dispatch"}:
              print(run.get("html_url", ""))
              sys.exit(0)

          sys.exit(1)
          PY
          }

          detect_existing_run() {
            local runs_json="$1"
            local run_url=""
            if run_url="$(find_run_url "${runs_json}")"; then
              echo "${run_url}"
              return 0
            fi
            return 1
          }

          for _ in 1 2 3 4 5 6; do
            RUNS_JSON="$(curl -fsSL \
              -H "Authorization: Bearer ${API_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${RUNS_API}")"

            if RUN_URL="$(detect_existing_run "${RUNS_JSON}")"; then
              echo "::notice::Workflow de producao detectado para tag ${TAG}: ${RUN_URL}"
              exit 0
            fi

            sleep 5
          done

          echo "::warning::Nao foi detectado run automatico por push de tag. Disparando workflow_dispatch em ${WORKFLOW_FILE}."
          curl -fsSL -X POST \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/workflows/${WORKFLOW_FILE}/dispatches" \
            -d "{\"ref\":\"${TAG}\"}"

          for _ in 1 2 3 4 5 6 7 8; do
            RUNS_JSON="$(curl -fsSL \
              -H "Authorization: Bearer ${API_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${RUNS_API}")"

            if RUN_URL="$(detect_existing_run "${RUNS_JSON}")"; then
              echo "::notice::Workflow de producao garantido para tag ${TAG}: ${RUN_URL}"
              exit 0
            fi

            sleep 5
          done

          echo "::error::Tag ${TAG} criada, mas nenhum run de producao foi encontrado para ${WORKFLOW_FILE}."
          echo "::error::Verifique permissao 'Actions: Read and write' no PAT em secrets.GIT_TOKEN e se o workflow ${WORKFLOW_FILE} existe no branch padrao."
          exit 1

      - name: Summary
        if: always()
        run: |
          {
            echo "## auto-tag-production"
            echo "- ref: \`${{ github.ref }}\`"
            echo "- tag: \`${{ steps.ver.outputs.tag }}\`"
            echo "- target workflow file: \`${{ steps.wf.outputs.workflow_file }}\`"
            echo "- tag pushed: \`${{ steps.push_tag.outputs.tag_pushed }}\`"
            echo "- tag ready: \`${{ steps.push_tag.outputs.tag_ready }}\`"
          } >> "$GITHUB_STEP_SUMMARY"
